diff -Nur 5.4.2.2/Makefile.am current.Bug188/Makefile.am
--- 5.4.2.2/Makefile.am	2004-10-23 03:26:49.000000000 +0000
+++ current.Bug188/Makefile.am	2005-09-27 03:59:00.000000000 +0000
@@ -1,3 +1,4 @@
+ACLOCAL_AMFLAGS = -I m4dir
 SUBDIRS = cilk2c runtime support examples doc FAQ
 EXTRA_DIST = THANKS bootstrap.sh
 
diff -Nur 5.4.2.2/Makefile.in current.Bug188/Makefile.in
--- 5.4.2.2/Makefile.in	2004-10-23 03:26:12.000000000 +0000
+++ current.Bug188/Makefile.in	2005-10-05 16:47:46.000000000 +0000
@@ -104,6 +104,7 @@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
+ACLOCAL_AMFLAGS = -I m4dir
 SUBDIRS = cilk2c runtime support examples doc FAQ
 EXTRA_DIST = THANKS bootstrap.sh
 
@@ -144,7 +145,7 @@
 $(srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(srcdir)/configure.ac $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
 	cd $(srcdir) && $(AUTOCONF)
 
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ configure.ac acinclude.m4
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ configure.ac acinclude.m4 m4dir/acx_pthread.m4
 	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
 
 config.h: stamp-h1
diff -Nur 5.4.2.2/SVN_VERSION current.Bug188/SVN_VERSION
--- 5.4.2.2/SVN_VERSION	2004-10-23 03:27:43.000000000 +0000
+++ current.Bug188/SVN_VERSION	2005-10-25 01:30:04.000000000 +0000
@@ -1 +1 @@
-1708
+2560
diff -Nur 5.4.2.2/cilk2c/ANSI-C.y current.Bug188/cilk2c/ANSI-C.y
--- 5.4.2.2/cilk2c/ANSI-C.y	2004-10-23 03:26:43.000000000 +0000
+++ current.Bug188/cilk2c/ANSI-C.y	2005-10-25 01:28:54.000000000 +0000
@@ -104,11 +104,9 @@
 #include "stringParse.h"
  
 FILE_IDENTITY(ident_ansi_c_y,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/ANSI-C.y $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/ANSI-C.y $ $LastChangedBy: bradley $ $Rev: 2561 $ $Date$");
 
-#ifndef YYDEBUG
 int yydebug=0;
-#endif
 
 extern int yylex(void);
 PRIVATE void WarnAboutPrecedence(OpType op, Node *node);
@@ -191,7 +189,7 @@
 ...
 
 */
-
+/* %debug */
 
 %union {
     Node      *n;
@@ -318,10 +316,10 @@
 %type <n> logical.AND.expression logical.OR.expression conditional.expression
 %type <n> assignment.expression constant.expression expression.opt
 %type <L> attributes.opt attributes attribute attribute.list 
-%type <n> attrib any.word asm.opt
+%type <n> attrib any.word asm.opt asm
 
 %type <n> initializer.opt initializer basic.initializer initializer.list bracketed.initializer.list
-%type <n> bit.field.size.opt bit.field.size enumerator.value.opt
+%type <n> bit.field.size enumerator.value.opt
 
 %type <n> statement labeled.statement expression.statement
 %type <n> selection.statement iteration.statement jump.statement
@@ -334,7 +332,7 @@
 %type <n> postfixing.abstract.declarator array.abstract.declarator
 %type <n> postfix.abstract.declarator old.function.declarator
 %type <n> struct.or.union.specifier struct.or.union elaborated.type.name
-%type <n> sue.type.specifier sue.declaration.specifier enum.specifier
+%type <n> sue.type.specifier sue.type.specifier.noatt sue.declaration.specifier enum.specifier
 
 %type <n> parameter.declaration
 %type <n> identifier.declarator parameter.typedef.declarator
@@ -357,10 +355,10 @@
 %type <n> identifier.or.typedef.name
 
 %type <tq> type.qualifier type.qualifier.list declaration.qualifier.list
-%type <tq> declaration.qualifier storage.class
+%type <tq> declaration.qualifier storage.class storage.class.noatt
 %type <tq> pointer.type.qualifier pointer.type.qualifier.list
 
-%type <n>  basic.type.name
+%type <n>  basic.type.name basic.type.name.noatt
 
 /* GCC extensions */
 %token <tok> ASM
@@ -728,12 +726,16 @@
  * These rules were just moved from the function.definition: rule.  -KHR
  */
         | declaration.specifier identifier.declarator
-            { $2 = DefineProc(FALSE, SetDeclType($2, $1, Redecl)); }
+            {
+	      Node *decl = SetDeclType($2, $1, Redecl);
+	      $2 = DefineProc(FALSE, decl);
+	    }
           compound.statement.no.new.scope
             { $$ = MakeNewList(SetProcBody($2, $4)); }
         | type.specifier identifier.declarator
 	    {
-	      $2 = DefineProc(FALSE, SetDeclType($2, $1, Redecl));
+	      Node *decl = SetDeclType($2, $1, Redecl);
+	      $2 = DefineProc(FALSE, decl);
 	      $2->pragmas_before = GrabPragmas(0);
 	    }
           compound.statement.no.new.scope
@@ -751,19 +753,49 @@
             { 
 	      SetDeclType($2, $1, Redecl);
 	    }
-          asm.opt { SetDeclAsm($2, $4); }
-          attributes.opt { AppendDeclAttribs($2, $6); }
+          asm { SetDeclAsm($2, $4); }
+          attributes.opt { SetDeclAttribs($2, $6); }
           initializer.opt
             { 
               $$ = MakeNewList(SetDeclInit($2, $8)); 
             }
+        | declaration.specifier
+          declarator
+            { 
+	      SetDeclType($2, $1, Redecl);
+	    }
+          attributes.opt
+            {
+		SetDeclAttribs($2, $4);
+            }
+          initializer.opt
+            { 
+	      //SetDeclAttribs($2, $4);
+              $$ = MakeNewList(SetDeclInit($2, $6)); 
+            }
+        | type.specifier 
+          declarator 
+            { 
+	      //printf("%s:%d ", __FILE__, __LINE__); DPN($2); 
+              SetDeclType($2, $1, Redecl);
+	      //printf("%s:%d ", __FILE__, __LINE__); DPN($2); 
+            }
+          attributes.opt
+          initializer.opt
+            { 
+	      //printf("%s:%d ", __FILE__, __LINE__); DPN($2); 
+	      SetDeclAttribs($2, $4);
+	      //printf("%s:%d ", __FILE__, __LINE__); DPN($2); 
+              $$ = MakeNewList(SetDeclInit($2, $5)); 
+	      //printf("%s:%d ", __FILE__, __LINE__); DPL($$); 
+	    }
         | type.specifier 
           declarator 
             { 
               SetDeclType($2, $1, Redecl);
             }
-          asm.opt { SetDeclAsm($2, $4); }
-          attributes.opt { AppendDeclAttribs($2, $6); }
+          asm { SetDeclAsm($2, $4); }
+          attributes.opt { SetDeclAttribs($2, $6); }
           initializer.opt
             { 
               $$ = MakeNewList(SetDeclInit($2, $8)); 
@@ -773,10 +805,14 @@
 	      $$ = AppendDecl($1, $3, Redecl);
 	    }
           asm.opt { SetDeclAsm($3, $5); }
-          attributes.opt { AppendDeclAttribs($3, $7); }
+          attributes.opt { SetDeclAttribs($3, $7); }
           initializer.opt
             { 
               SetDeclInit($3, $9); 
+	      if (yydebug) {
+		  printf("%s:%d ", __FILE__, __LINE__); DPL($7); 
+		  printf("%s:%d ", __FILE__, __LINE__); DPN($3);
+	      }
             }
 
         /******** ERROR PRODUCTIONS ********/
@@ -813,7 +849,9 @@
             { 
               SetDeclType($2, MakeDefaultPrimType($1.tq, $1.coord), NoRedecl);
             }
-          attributes.opt { SetDeclAttribs($2, $4); }
+          attributes.opt {
+              SetDeclAttribs($2, $4);
+          }
 	  initializer.opt
             { 
               $$ = MakeNewList(SetDeclInit($2, $6)); 
@@ -822,7 +860,9 @@
             { 
               SetDeclType($2, MakeDefaultPrimType($1.tq, $1.coord), NoRedecl);
             }
-          attributes.opt { SetDeclAttribs($2, $4); }
+          attributes.opt {
+	    SetDeclAttribs($2, $4);
+	  }
 	  initializer.opt
             { 
               $$ = MakeNewList(SetDeclInit($2, $6)); 
@@ -889,8 +929,8 @@
 sue.declaration.specifier: /*P*/   
           sue.type.specifier storage.class
             { $$ = TypeQualifyNode($1, $2.tq, & $2.coord); }
-        | declaration.qualifier.list elaborated.type.name
-            { $$ = TypeQualifyNode($2, $1.tq, & $1.coord); }
+        | declaration.qualifier.list elaborated.type.name attributes.opt
+            { $$ = TypeQualifyNode($2, tq_union($1.tq, tq_attribute($3)), & $1.coord); }
         | sue.declaration.specifier declaration.qualifier
             { $$ = TypeQualifyNode($1, $2.tq, & $2.coord); }
         ;
@@ -900,8 +940,11 @@
 typedef.declaration.specifier:  /*P*/      
           typedef.type.specifier storage.class
             { $$ = TypeQualifyNode($1, $2.tq, & $2.coord); }
-        | declaration.qualifier.list TYPEDEFname
-            { $$ = ConvertIdToTdef($2, $1.tq, GetTypedefType($2)); $$->coord = $1.coord; }
+        | declaration.qualifier.list TYPEDEFname attributes.opt
+            { $$ = ConvertIdToTdef($2, $1.tq, GetTypedefType($2));
+              $$->coord = $1.coord;
+	      NodeUpdateTq2($$, tq_union, tq_attribute($3));
+            }
         | typedef.declaration.specifier declaration.qualifier
             { $$ = TypeQualifyNode($1, $2.tq, & $2.coord); }
         ;
@@ -914,14 +957,21 @@
             { $$.tq = MergeTypeQuals($1.tq, $2.tq, $2.coord);
               $$.coord = $1.coord; }
         | declaration.qualifier.list declaration.qualifier
-            { $$.tq = MergeTypeQuals($1.tq, $2.tq, $2.coord);
-              $$.coord = $1.coord; }
+            {
+              $$.tq = MergeTypeQuals($1.tq, $2.tq, $2.coord);
+              $$.coord = $1.coord; 
+	    }
+/*
+        | declaration.qualifier.list  attribute
+           {  $$.tq = tq_union($1.tq, tq_attribute($2));
+	      $$.coord = $1.coord; }
+*/
         ;
 
 /*                        */    /* ? */ /* ?.?.? */
 declaration.qualifier: /*P*/
           type.qualifier
-        | storage.class
+          | storage.class
         ;
 
 typeof.expression: 
@@ -931,11 +981,19 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 type.specifier: /*P*/
-          basic.type.specifier               /* Arithmetic or void */
-            { $$ = FinishPrimType($1); }
+          basic.type.specifier attributes.opt       /* Arithmetic or void */
+            { $$ = FinishPrimType($1);
+              $$ = TypeQualifyNode($$, tq_attribute($2), NULL);
+             }
         | sue.type.specifier                 /* Struct/Union/Enum  */
-        | typedef.type.specifier             /* Typedef            */
-        | typeof.type.specifier              /* This is really a gcc extension */
+        | typedef.type.specifier attributes.opt            /* Typedef            */
+            {
+              $$ = TypeQualifyNode($1, tq_attribute($2), NULL);
+            }
+        | typeof.type.specifier attributes.opt             /* This is really a gcc extension */
+            {
+              $$ = TypeQualifyNode($1, tq_attribute($2), NULL);
+            }
         ;
 
 typeof.type.specifier:
@@ -948,7 +1006,7 @@
             {
 		$$ = NodeCopy(NodeDataType(SemCheckNode($3)), Subtree); /* copy the node so we can remove type qualifiers without hurting the code */	      
 		SetCoords($$, $1, Subtree);
-	        NodeRemoveTq($$, -1); /* Take off all the type qualifiers */
+		NodeUpdateTq($$, tq_remove_everything); /* Take off all the type qualifiers */
 	    }
 	| type.qualifier.list TYPEOF '(' typeof.expression ')'   /* gcc extension      */
   	    /*
@@ -959,7 +1017,7 @@
             {
 		/* we have to copy the node because we don't want the type qualifiers to modify the original node. */
 		Node *thetype=SetCoords(NodeCopy(NodeDataType(SemCheckNode($4)), Subtree), $2, Subtree);
-		NodeRemoveTq(thetype, -1); /* Take off all the type qualifiers */		    
+		NodeUpdateTq(thetype, tq_remove_everything); /* Take off all the type qualifiers */
 		$$ = TypeQualifyNode(thetype, $1.tq, & $1.coord); /* Add on the new type qualifiers */
 	    }
         ;
@@ -976,7 +1034,11 @@
         ;
 
 /*                        */    /* ? */ /* ?.?.? */
-sue.type.specifier: /*P*/
+sue.type.specifier:
+          sue.type.specifier.noatt attributes.opt
+             { $$ = TypeQualifyNode($1, tq_attribute($2), 0); }
+;
+sue.type.specifier.noatt: /*P*/
           elaborated.type.name              /* struct/union/enum */
         | type.qualifier.list elaborated.type.name
             { $$ = TypeQualifyNode($2, $1.tq, & $1.coord); }
@@ -997,7 +1059,9 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 type.qualifier.list: /*P*/
-          type.qualifier
+          type.qualifier attributes.opt 
+            { $$.tq = tq_union($1.tq, tq_attribute($2));
+	      $$.coord = $1.coord; }
         | type.qualifier.list type.qualifier
             { $$.tq = MergeTypeQuals($1.tq, $2.tq, $2.coord);
               $$.coord = $1.coord; }
@@ -1033,17 +1097,17 @@
 /* Redundant '(' placed immediately to the left of the TYPEDEFname  */
 paren.typedef.declarator: /*P*/
           paren.postfix.typedef.declarator
-        | '*' paren.typedef.declarator
-            { $$ = SetDeclType($2, MakePtrCoord(EMPTY_TQ, NULL, $1), Redecl);
+        | '*' attributes.opt paren.typedef.declarator  /* UNUSED attributes.opt */
+            { $$ = SetDeclType($3, MakePtrCoord(EMPTY_TQ, NULL, $1), Redecl);
                }
-        | '*' '(' simple.paren.typedef.declarator ')' 
-            { $$ = SetDeclType($3, MakePtrCoord(EMPTY_TQ, NULL, $1), Redecl); 
+        | '*' attributes.opt '(' simple.paren.typedef.declarator ')'  /* UNUSED attributes.opt */
+            { $$ = SetDeclType($4, MakePtrCoord(EMPTY_TQ, NULL, $1), Redecl); 
                }
-        | '*' pointer.type.qualifier.list '(' simple.paren.typedef.declarator ')' 
-            { $$ = SetDeclType($4, MakePtrCoord(   $2.tq,    NULL, $1), Redecl);
+        | '*' attributes.opt pointer.type.qualifier.list '(' simple.paren.typedef.declarator ')'  /* UNUSED attributes.opt */
+            { $$ = SetDeclType($5, MakePtrCoord(   $3.tq,    NULL, $1), Redecl);
                }
-        | '*' pointer.type.qualifier.list paren.typedef.declarator
-            { $$ = SetDeclType($3, MakePtrCoord(   $2.tq,    NULL, $1), Redecl); 
+        | '*' attributes.opt pointer.type.qualifier.list paren.typedef.declarator  /* UNUSED attributes.opt */
+            { $$ = SetDeclType($4, MakePtrCoord(   $3.tq,    NULL, $1), Redecl); 
                }
         ;
         
@@ -1086,11 +1150,11 @@
 /*                        */    /* ? */ /* ?.?.? */
 clean.typedef.declarator: /*P*/
           clean.postfix.typedef.declarator
-        | '*' parameter.typedef.declarator
-            { $$ = SetDeclType($2, MakePtrCoord(EMPTY_TQ, NULL, $1), Redecl); 
+        | '*' attributes.opt parameter.typedef.declarator  /* UNUSED attributes.opt */
+            { $$ = SetDeclType($3, MakePtrCoord(EMPTY_TQ, NULL, $1), Redecl); 
                }
-        | '*' pointer.type.qualifier.list parameter.typedef.declarator  
-            { $$ = SetDeclType($3, MakePtrCoord($2.tq, NULL, $1), Redecl); 
+        | '*' attributes.opt pointer.type.qualifier.list parameter.typedef.declarator   /* UNUSED attributes.opt */ 
+            { $$ = SetDeclType($4, MakePtrCoord($3.tq, NULL, $1), Redecl); 
                }
         ;
 
@@ -1113,15 +1177,15 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 unary.abstract.declarator: /*P*/
-          '*' 
+          '*' attributes.opt  /* UNUSED attributes.opt */
             { $$ = MakePtrCoord(EMPTY_TQ, NULL, $1); }
-        | '*' pointer.type.qualifier.list 
-            { $$ = MakePtrCoord($2.tq, NULL, $1); }
-        | '*' abstract.declarator
-            { $$ = SetBaseType($2, MakePtrCoord(EMPTY_TQ, NULL, $1)); 
+        | '*' attributes.opt pointer.type.qualifier.list   /* UNUSED attributes.opt */
+            { $$ = MakePtrCoord($3.tq, NULL, $1); }
+        | '*' attributes.opt abstract.declarator  /* UNUSED attributes.opt */
+            { $$ = SetBaseType($3, MakePtrCoord(EMPTY_TQ, NULL, $1)); 
                }
-        | '*' pointer.type.qualifier.list abstract.declarator
-            { $$ = SetBaseType($3, MakePtrCoord($2.tq, NULL, $1)); 
+        | '*' attributes.opt pointer.type.qualifier.list abstract.declarator  /* UNUSED attributes.opt */
+            { $$ = SetBaseType($4, MakePtrCoord($3.tq, NULL, $1)); 
                }
         ;
 
@@ -1158,11 +1222,13 @@
 /*                        */    /* ? */ /* ?.?.? */
 unary.identifier.declarator: /*P293*/
           postfix.identifier.declarator
-        | '*' identifier.declarator
-            { $$ = ModifyDeclType($2, MakePtrCoord(EMPTY_TQ, NULL, $1)); 
-               }
-        | '*' pointer.type.qualifier.list identifier.declarator
-            { $$ = ModifyDeclType($3, MakePtrCoord(   $2.tq,    NULL, $1)); 
+        | '*' attributes.opt identifier.declarator
+            { //printf("%s:%d ", __FILE__, __LINE__); DPL($2);
+              SetDeclAttribs($3, $2);
+              $$ = ModifyDeclType($3, MakePtrCoord(EMPTY_TQ, NULL, $1)); 
+              }
+        | '*' attributes.opt pointer.type.qualifier.list identifier.declarator
+            { $$ = ModifyDeclType($4, MakePtrCoord(tq_union(tq_attribute($2), $3.tq),    NULL, $1)); 
                }
         ;
         
@@ -1200,11 +1266,11 @@
             { 
               $$ = $1; 
             }
-        | '*' old.function.declarator
-            { $$ = SetDeclType($2, MakePtrCoord(EMPTY_TQ, NULL, $1), SU); 
+        | '*' attributes.opt old.function.declarator /* UNUSED attributes.opt */
+            { $$ = SetDeclType($3, MakePtrCoord(EMPTY_TQ, NULL, $1), SU); 
                }
-        | '*' pointer.type.qualifier.list old.function.declarator
-            { $$ = SetDeclType($3, MakePtrCoord($2.tq, NULL, $1), SU); 
+        | '*' attributes.opt pointer.type.qualifier.list old.function.declarator  /* UNUSED attributes.opt */
+            { $$ = SetDeclType($4, MakePtrCoord($3.tq, NULL, $1), SU); 
                }
         ;
 
@@ -1306,7 +1372,9 @@
          *     aligned(8)         (that is this last rule)
          *     packed             (that is the first rule)
          *     section("shared")  (that is this last rule)
-         *                        I think the other rules are needed for the format attributes.  -Bradley
+	 * The problem is that the IDENTIFIER, if parsed as an expression, will
+	 *     be parsed as an undeclared variable.  (It could even be a type name
+	 *     which will be parsed badly too.
          */
 	| any.word '(' nonnull.expression.list ')'
                 { $$ = ConvertIdToAttrib($1, $3); }
@@ -1321,9 +1389,12 @@
 asm.opt:
 	  /* empty */
              { $$ = NULL; }    
-        | ASM '(' string.literal.list ')' 
-             { $$ = MakeAsmCoord(EMPTY_TQ, $3, NULL, NULL, NULL, $1); }
+        | asm
 	;
+asm:
+          ASM '(' string.literal.list ')' 
+             { $$ = MakeAsmCoord(EMPTY_TQ, $3, NULL, NULL, NULL, $1); }
+;
 
 any.word:
 	  IDENTIFIER
@@ -1407,42 +1478,41 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 parameter.declaration: /*P*/
-          declaration.specifier
-            { $$ = $1; }
-        | declaration.specifier abstract.declarator
-            { $$ = SetBaseType($2, $1); 
+          attributes.opt declaration.specifier
+            { $$ = $2; }
+        | attributes.opt declaration.specifier abstract.declarator
+            { $$ = SetBaseType($3, $2); 
             }
-        | declaration.specifier identifier.declarator
-            { $$ = SetDeclType($2, $1, Formal); 
+        | attributes.opt declaration.specifier identifier.declarator
+            { $$ = SetDeclType($3, $2, Formal); 
             }
-        | declaration.specifier parameter.typedef.declarator
-            { $$ = SetDeclType($2, $1, Formal); 
+        | attributes.opt declaration.specifier parameter.typedef.declarator
+            { $$ = SetDeclType($3, $2, Formal); 
             }
-        | declaration.qualifier.list /* DEFAULT_INT */ 
-            { $$ = MakeDefaultPrimType($1.tq, $1.coord); }
-        | declaration.qualifier.list /* DEFAULT_INT */ abstract.declarator
-            { $$ = SetBaseType($2, MakeDefaultPrimType($1.tq, $1.coord)); }
-        | declaration.qualifier.list /* DEFAULT_INT */ identifier.declarator
-            { $$ = SetDeclType($2, MakeDefaultPrimType($1.tq, $1.coord), Formal); }
-        | type.specifier
-            { $$ = $1; }
-        | type.specifier abstract.declarator
-            { $$ = SetBaseType($2, $1); 
+        | attributes.opt declaration.qualifier.list /* DEFAULT_INT */ 
+            { $$ = MakeDefaultPrimType($2.tq, $2.coord); }
+        | attributes.opt declaration.qualifier.list /* DEFAULT_INT */ abstract.declarator
+            { $$ = SetBaseType($3, MakeDefaultPrimType($2.tq, $2.coord)); }
+        | attributes.opt declaration.qualifier.list /* DEFAULT_INT */ identifier.declarator
+            { $$ = SetDeclType($3, MakeDefaultPrimType($2.tq, $2.coord), Formal); }
+        | attributes.opt type.specifier
+            { $$ = $2; }
+        | attributes.opt type.specifier abstract.declarator
+            { $$ = SetBaseType($3, $2); 
             }
-        | type.specifier identifier.declarator attributes.opt
+        | attributes.opt type.specifier identifier.declarator attributes.opt
             {
-	      SetDeclAttribs($2, $3);
-	      $$ = SetDeclType($2, $1, Formal);
-            }
-        | type.specifier parameter.typedef.declarator
-            { $$ = SetDeclType($2, $1, Formal); 
+	      $$ = SetDeclType($3, TypeQualifyNode($2, tq_attribute(JoinLists($1,$4)), NULL), Formal)
+	    }
+        | attributes.opt type.specifier parameter.typedef.declarator
+            { $$ = SetDeclType($3, $2, Formal); 
             }
-        | type.qualifier.list /* DEFAULT_INT */ 
-            { $$ = MakeDefaultPrimType($1.tq, $1.coord); }
-        | type.qualifier.list /* DEFAULT_INT */ abstract.declarator
-            { $$ = SetBaseType($2, MakeDefaultPrimType($1.tq, $1.coord)); }
-        | type.qualifier.list /* DEFAULT_INT */ identifier.declarator
-            { $$ = SetDeclType($2, MakeDefaultPrimType($1.tq, $1.coord), Formal); }
+        | attributes.opt type.qualifier.list /* DEFAULT_INT */ 
+            { $$ = MakeDefaultPrimType($2.tq, $2.coord); }
+        | attributes.opt type.qualifier.list /* DEFAULT_INT */ abstract.declarator
+            { $$ = SetBaseType($3, MakeDefaultPrimType($2.tq, $2.coord)); }
+        | attributes.opt type.qualifier.list /* DEFAULT_INT */ identifier.declarator
+            { $$ = SetDeclType($3, MakeDefaultPrimType(tq_union(tq_attribute($1),$2.tq), $2.coord), Formal); }
         ;
 
 /*                        */    /* ? */ /* ?.?.? */
@@ -1475,31 +1545,31 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 struct.or.union.specifier: /*P*/
-          struct.or.union '{' struct.declaration.list '}' attributes.opt
+          struct.or.union '{' struct.declaration.list '}'
             { 
-              $$ = SetSUdclNameFields($1, NULL, $3, $2, $4, $5);
+              $$ = SetSUdclNameFields($1, NULL, $3, $2, $4, NULL);
             }
         | struct.or.union identifier.or.typedef.name
-          '{' struct.declaration.list '}' attributes.opt
+          '{' struct.declaration.list '}'
             { 
-              $$ = SetSUdclNameFields($1, $2, $4, $3, $5, $6);
+              $$ = SetSUdclNameFields($1, $2, $4, $3, $5, NULL);
 	    }
         | struct.or.union identifier.or.typedef.name
             { 
               $$ = SetSUdclName($1, $2, $1->coord);
 	    }
         /* EAB: create rules for empty structure declarations */
-        | struct.or.union '{' '}' attributes.opt
+        | struct.or.union '{' '}'
             { 
               if (ANSIOnly)
                  Warning(1, "empty structure declaration");
-              $$ = SetSUdclNameFields($1, NULL, NULL, $2, $3, $4);
+              $$ = SetSUdclNameFields($1, NULL, NULL, $2, $3, NULL);
 	    }
-        | struct.or.union identifier.or.typedef.name '{' '}' attributes.opt
+        | struct.or.union identifier.or.typedef.name '{' '}'
             { 
               if (ANSIOnly)
                  Warning(1, "empty structure declaration");
-              $$ = SetSUdclNameFields($1, $2, NULL, $3, $4, $5); 
+              $$ = SetSUdclNameFields($1, $2, NULL, $3, $4, NULL); 
 	    }
         ;
 
@@ -1520,7 +1590,7 @@
 struct.declaration: /*P*/
           struct.declaring.list ';'
         | struct.default.declaring.list ';'
-        | gcc.extension struct.declaration { $$ = $2; NodeAddTq((Node*)(FirstItem($$)), T_EXTENSION); ((Node*)(FirstItem($$)))->coord = $1; }
+        | gcc.extension struct.declaration { $$ = $2; NodeUpdateTq((Node*)(FirstItem($$)), tq_add_extension); ((Node*)(FirstItem($$)))->coord = $1; }
         ;
 
 /* doesn't redeclare typedef */
@@ -1547,7 +1617,10 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 struct.declarator: /*P*/
-          declarator bit.field.size.opt attributes.opt
+          declarator attributes.opt
+            { SetDeclAttribs($1,$2);
+	      $$ = $1; }
+        | declarator bit.field.size attributes.opt
             { SetDeclAttribs($1, $3);
               $$ = SetDeclBitSize($1, $2); }
         | bit.field.size attributes.opt
@@ -1557,7 +1630,8 @@
 
 /*                        */    /* ? */ /* ?.?.? */
 struct.identifier.declarator: /*P*/
-          identifier.declarator bit.field.size.opt attributes.opt
+          identifier.declarator
+        | identifier.declarator bit.field.size attributes.opt
             { $$ = SetDeclBitSize($1, $2);
               SetDeclAttribs($1, $3); }
         | bit.field.size attributes.opt
@@ -1565,11 +1639,6 @@
               SetDeclAttribs($$, $2); }
         ;
 
-/*                        */    /* ? */ /* ?.?.? */
-bit.field.size.opt: /*P*/
-          /* nothing */   { $$ = NULL; }
-        | bit.field.size
-        ;
 
 /*                        */    /* ? */ /* ?.?.? */
 bit.field.size: /*P*/
@@ -1834,7 +1903,7 @@
               if (yydebug)
                 {
                   printf("external.definition # declaration\n");
-                  PrintNode(stdout, FirstItem($1), 0); 
+                  fPrintNode(stdout, FirstItem($1), 0); 
                   printf("\n\n\n");
 		}
               $$ = $1;
@@ -1844,7 +1913,7 @@
               if (yydebug)
                 {
                   printf("external.definition # function.definition\n");
-                  PrintNode(stdout, $1, 0); 
+                  fPrintNode(stdout, $1, 0); 
                   printf("\n\n\n");
                 }
               $$ = MakeNewList($1);
@@ -1880,19 +1949,19 @@
 */
         | declaration.qualifier.list identifier.declarator
             { 
-              $2 = DefineProc(FALSE, 
-	                      SetDeclType($2,
-				 	  MakeDefaultPrimType($1.tq, $1.coord),
-				          Redecl));
+	      Node *decl = SetDeclType($2,
+				       MakeDefaultPrimType($1.tq, $1.coord),
+				       Redecl);
+	      $2 = DefineProc(FALSE, decl);
             } 
           compound.statement.no.new.scope
             { $$ = SetProcBody($2, $4); }
         | type.qualifier.list        identifier.declarator
             { 
-              $2 = DefineProc(FALSE, 
-                              SetDeclType($2,
-					  MakeDefaultPrimType($1.tq, $1.coord),
-					  Redecl));
+	      Node *decl = SetDeclType($2,
+				       MakeDefaultPrimType($1.tq, $1.coord),
+				       Redecl);
+	      $2 = DefineProc(FALSE, decl);
             } 
           compound.statement.no.new.scope
             { $$ = SetProcBody($2, $4); }
@@ -2033,39 +2102,55 @@
         ;
 
 type.qualifier: /*P*/
-          CONST     { $$.tq = T_CONST;    $$.coord = $1; } 
-        | VOLATILE  { $$.tq = T_VOLATILE; $$.coord = $1; }
-        | INLINE    { $$.tq = T_INLINE;   $$.coord = $1; } /* gcc extension */
-        | RESTRICT  { $$.tq = T_RESTRICT; $$.coord = $1; } /* C9X extension */
-        | COMPLEX   { $$.tq = T_COMPLEX;  $$.coord = $1; } /* c9x extension */
-        | PROCEDURE { $$.tq = T_PROCEDURE;$$.coord = $1; } /* Cilk extension */
-        | INLET     { $$.tq = T_INLET;    $$.coord = $1; } /* Cilk extension */
-        | SHAREDVAR { $$.tq = T_SHARED;   $$.coord = $1; } /* Cilk extension */
-        | PRIVATEVAR{ $$.tq = T_PRIVATE;  $$.coord = $1; } /* Cilk extension */
-        | NOOUTPUT  { $$.tq = T_NOOUTPUT; $$.coord = $1; } /* cilk2c extension */
-        | CILKONLY  { $$.tq = T_CILKONLY; $$.coord = $1; } /* cilk2c extension */
-        | CILKSAFE  { $$.tq = T_CILKSAFE; $$.coord = $1; } /* cilk2c extension */
+          CONST     { $$.tq = TQ_CONST;    $$.coord = $1; } 
+        | VOLATILE  { $$.tq = TQ_VOLATILE; $$.coord = $1; }
+        | INLINE    { $$.tq = TQ_INLINE;   $$.coord = $1; } /* gcc extension */
+        | RESTRICT  { $$.tq = TQ_RESTRICT; $$.coord = $1; } /* C9X extension */
+        | COMPLEX   { $$.tq = TQ_COMPLEX;  $$.coord = $1; } /* c9x extension */
+        | PROCEDURE { $$.tq = TQ_PROCEDURE;$$.coord = $1; } /* Cilk extension */
+        | INLET     { $$.tq = TQ_INLET;    $$.coord = $1; } /* Cilk extension */
+        | SHAREDVAR { $$.tq = TQ_SHARED;   $$.coord = $1; } /* Cilk extension */
+        | PRIVATEVAR{ $$.tq = TQ_PRIVATE;  $$.coord = $1; } /* Cilk extension */
+        | NOOUTPUT  { $$.tq = TQ_NOOUTPUT; $$.coord = $1; } /* cilk2c extension */
+        | CILKONLY  { $$.tq = TQ_CILKONLY; $$.coord = $1; } /* cilk2c extension */
+        | CILKSAFE  { $$.tq = TQ_CILKSAFE; $$.coord = $1; } /* cilk2c extension */
         ;
 
 pointer.type.qualifier: /*P*/
-          CONST     { $$.tq = T_CONST;    $$.coord = $1; } 
-        | VOLATILE  { $$.tq = T_VOLATILE; $$.coord = $1; }
-        | RESTRICT  { $$.tq = T_RESTRICT; $$.coord = $1; } /* C9X extension */
-        | PROCEDURE { $$.tq = T_PROCEDURE;$$.coord = $1; } /* Cilk extension */
-        | INLET     { $$.tq = T_INLET;    $$.coord = $1; } /* Cilk extension */
-        | CILKONLY  { $$.tq = T_CILKONLY; $$.coord = $1; } /* cilk2c extension */
-        | CILKSAFE  { $$.tq = T_CILKSAFE; $$.coord = $1; } /* cilk2c extension */
+          CONST     { $$.tq = TQ_CONST;    $$.coord = $1; } 
+        | VOLATILE  { $$.tq = TQ_VOLATILE; $$.coord = $1; }
+        | RESTRICT  { $$.tq = TQ_RESTRICT; $$.coord = $1; } /* C9X extension */
+        | PROCEDURE { $$.tq = TQ_PROCEDURE;$$.coord = $1; } /* Cilk extension */
+        | INLET     { $$.tq = TQ_INLET;    $$.coord = $1; } /* Cilk extension */
+        | CILKONLY  { $$.tq = TQ_CILKONLY; $$.coord = $1; } /* cilk2c extension */
+        | CILKSAFE  { $$.tq = TQ_CILKSAFE; $$.coord = $1; } /* cilk2c extension */
         ;
 
 storage.class: /*P*/
-          TYPEDEF   { $$.tq = T_TYPEDEF;  $$.coord = $1; } 
-        | EXTERN    { $$.tq = T_EXTERN;   $$.coord = $1; } 
-        | STATIC    { $$.tq = T_STATIC;   $$.coord = $1; } 
-        | AUTO      { $$.tq = T_AUTO;     $$.coord = $1; } 
-        | REGISTER  { $$.tq = T_REGISTER; $$.coord = $1; } 
+          storage.class.noatt attributes.opt
+           { 
+             $$ = $1;
+             $$.tq = tq_union($1.tq, tq_attribute($2));
+           }
+;
+
+storage.class.noatt:
+          TYPEDEF   { $$.tq = TQ_TYPEDEF;  $$.coord = $1; } 
+        | EXTERN    { $$.tq = TQ_EXTERN;   $$.coord = $1; } 
+        | STATIC    { $$.tq = TQ_STATIC;   $$.coord = $1; } 
+        | AUTO      { $$.tq = TQ_AUTO;     $$.coord = $1; } 
+        | REGISTER  { $$.tq = TQ_REGISTER; $$.coord = $1; } 
         ;
 
 basic.type.name: /*P*/
+          basic.type.name.noatt attributes.opt
+            {
+	      $$ = $1;
+	      NodeUpdateTq2($$, tq_union, tq_attribute($2));
+	    }
+;
+
+basic.type.name.noatt: /*P*/
           VOID      { $$ = StartPrimType(Void, $1);    } 
         | CHAR      { $$ = StartPrimType(Char, $1);     } 
         | INT       { $$ = StartPrimType(Int_ParseOnly, $1);     } 
diff -Nur 5.4.2.2/cilk2c/Makefile.am current.Bug188/cilk2c/Makefile.am
--- 5.4.2.2/cilk2c/Makefile.am	2004-10-23 03:26:46.000000000 +0000
+++ current.Bug188/cilk2c/Makefile.am	2005-10-22 02:52:38.000000000 +0000
@@ -9,11 +9,14 @@
 simplify.c                                                              \
 sideeffects.c                                                           \
 sem-check.c strings.c                                                   \
-sue.c symbol.c transform.c type.c type2.c verify-parse.c warning.c	\
+sue.c symbol.c transform.c type.c type2.c typequal.c verify-parse.c     \
+warning.c	                                                        \
+gbuf.h gbuf.c                                                           \
 ast.h basics.h config.h conversions.h dataflow.h heap.h initializer.h	\
-list.h operators.h symbol.h type.h ANSI-C.c ANSI-C.h c4.l hint.c        \
+list.h operators.h symbol.h type.h typequal.h ANSI-C.c ANSI-C.h c4.l    \
+hint.c                                                                  \
 astModify.h astModify.c stringParse.h stringParse.c wildcard.h wildcard.c \
-astEquals.h astEquals.c wildcardTable.h wildcardTable.c testEquals.h \
+astEquals.h astEquals.c wildcardTable.h wildcardTable.c testEquals.h    \
 testEquals.c atmTransform.h atmTransform.c
 
 YFLAGS = -d
diff -Nur 5.4.2.2/cilk2c/Makefile.in current.Bug188/cilk2c/Makefile.in
--- 5.4.2.2/cilk2c/Makefile.in	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/Makefile.in	2005-10-22 02:52:37.000000000 +0000
@@ -115,11 +115,14 @@
 simplify.c                                                              \
 sideeffects.c                                                           \
 sem-check.c strings.c                                                   \
-sue.c symbol.c transform.c type.c type2.c verify-parse.c warning.c	\
+sue.c symbol.c transform.c type.c type2.c typequal.c verify-parse.c     \
+warning.c	                                                        \
+gbuf.h gbuf.c                                                           \
 ast.h basics.h config.h conversions.h dataflow.h heap.h initializer.h	\
-list.h operators.h symbol.h type.h ANSI-C.c ANSI-C.h c4.l hint.c        \
+list.h operators.h symbol.h type.h typequal.h ANSI-C.c ANSI-C.h c4.l    \
+hint.c                                                                  \
 astModify.h astModify.c stringParse.h stringParse.c wildcard.h wildcard.c \
-astEquals.h astEquals.c wildcardTable.h wildcardTable.c testEquals.h \
+astEquals.h astEquals.c wildcardTable.h wildcardTable.c testEquals.h    \
 testEquals.c atmTransform.h atmTransform.c
 
 
@@ -149,8 +152,9 @@
 	procedure.$(OBJEXT) profile.$(OBJEXT) simplify.$(OBJEXT) \
 	sideeffects.$(OBJEXT) sem-check.$(OBJEXT) strings.$(OBJEXT) \
 	sue.$(OBJEXT) symbol.$(OBJEXT) transform.$(OBJEXT) \
-	type.$(OBJEXT) type2.$(OBJEXT) verify-parse.$(OBJEXT) \
-	warning.$(OBJEXT) ANSI-C.$(OBJEXT) c4.$(OBJEXT) hint.$(OBJEXT) \
+	type.$(OBJEXT) type2.$(OBJEXT) typequal.$(OBJEXT) \
+	verify-parse.$(OBJEXT) warning.$(OBJEXT) gbuf.$(OBJEXT) \
+	ANSI-C.$(OBJEXT) c4.$(OBJEXT) hint.$(OBJEXT) \
 	astModify.$(OBJEXT) stringParse.$(OBJEXT) wildcard.$(OBJEXT) \
 	astEquals.$(OBJEXT) wildcardTable.$(OBJEXT) \
 	testEquals.$(OBJEXT) atmTransform.$(OBJEXT)
@@ -173,17 +177,18 @@
 @AMDEP_TRUE@	./$(DEPDIR)/complex-types.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/constexpr.Po ./$(DEPDIR)/container.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/conversions.Po ./$(DEPDIR)/dataflow.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/elide.Po ./$(DEPDIR)/hint.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/initializer.Po ./$(DEPDIR)/list.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/main.Po ./$(DEPDIR)/operators.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/output.Po ./$(DEPDIR)/print-ast.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/procedure.Po ./$(DEPDIR)/profile.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/sem-check.Po ./$(DEPDIR)/sideeffects.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/simplify.Po ./$(DEPDIR)/stringParse.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/strings.Po ./$(DEPDIR)/sue.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/symbol.Po ./$(DEPDIR)/testEquals.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/transform.Po ./$(DEPDIR)/type.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/type2.Po ./$(DEPDIR)/verify-parse.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/elide.Po ./$(DEPDIR)/gbuf.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/hint.Po ./$(DEPDIR)/initializer.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/list.Po ./$(DEPDIR)/main.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/operators.Po ./$(DEPDIR)/output.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/print-ast.Po ./$(DEPDIR)/procedure.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/profile.Po ./$(DEPDIR)/sem-check.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/sideeffects.Po ./$(DEPDIR)/simplify.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/stringParse.Po ./$(DEPDIR)/strings.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/sue.Po ./$(DEPDIR)/symbol.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/testEquals.Po ./$(DEPDIR)/transform.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/type.Po ./$(DEPDIR)/type2.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/typequal.Po ./$(DEPDIR)/verify-parse.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/warning.Po ./$(DEPDIR)/wildcard.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/wildcardTable.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
@@ -262,6 +267,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/conversions.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dataflow.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elide.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gbuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hint.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/initializer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list.Po@am__quote@
@@ -282,6 +288,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transform.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/type.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/type2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/typequal.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/verify-parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/warning.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wildcard.Po@am__quote@
diff -Nur 5.4.2.2/cilk2c/analyze.c current.Bug188/cilk2c/analyze.c
--- 5.4.2.2/cilk2c/analyze.c	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/analyze.c	2005-10-22 02:52:37.000000000 +0000
@@ -28,7 +28,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/analyze.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/analyze.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 
 #define Gen(n)  ((n)->analysis.gen)
@@ -404,7 +404,9 @@
 		   end_coord = node->u.proc.body->u.Block.right_coord;
 
 		   if (!IsVoidType(type) &&
-		       (!TypeIsSint(type) || TYPE_QUALS(node->u.proc.decl->u.decl.type->u.fdcl.tq) & (T_PROCEDURE | T_INLET)) &&
+		       (!TypeIsSint(type) ||
+			tq_has_procedure(node->u.proc.decl->u.decl.type->u.fdcl.tq) ||
+			tq_has_inlet    (node->u.proc.decl->u.decl.type->u.fdcl.tq)) &&
 		       IsBitSet(v, REACHABLE)) {
 			WarningCoord(3, end_coord,
 			     "control reaches end of non-void function");
@@ -661,7 +663,7 @@
       * conservative for slow version). */
      IterateList(&marker, vars);
      while (NextOnList(&marker, (GenericREF) & var)) {
-	  if (NodeDeclLocation(var) == T_FORMAL_DECL)
+	  if (tq_has_formal_decl(NodeDeclLocation(var)))
 	       formals = SetUnion(formals, ListFind(vars, var));
      }
 
@@ -698,12 +700,15 @@
 
 GLOBAL void PV(List *vars)
 {
-     PrintVariables(stdout, vars);
-     putchar('\n');
-     fflush(stdout);
+    GBUF *gb = make_file_gbuf(stdout);
+    PrintVariables(gb, vars);
+    
+    putchar('\n');
+    fflush(stdout);
+    free_gbuf(gb);
 }
 
-GLOBAL int PrintVariables(FILE *out, List *vars)
+GLOBAL int PrintVariables(GBUF *gb, List *vars)
 {
      ListMarker m;
      Node *var;
@@ -711,18 +716,18 @@
 
      IterateList(&m, vars);
      while (NextOnList(&m, (GenericREF) & var))
-	  len += fprintf(out, "%s ", var->u.decl.name);
+	  len += gbprintf(gb, "%s ", var->u.decl.name);
      return len;
 }
 
-GLOBAL int PrintAnalysis(FILE *out, Node *node)
+GLOBAL int PrintAnalysis(GBUF *gb, Node *node)
 {
      int len = 0;
 
-     len += fprintf(out, "Live: ");
-     len += PrintVariables(out, LiveVars(node));
-     len += fprintf(out, "Dirty: ");
-     len += PrintVariables(out, DirtyVars(node));
+     len += gbprintf(gb, "Live: ");
+     len += PrintVariables(gb, LiveVars(node));
+     len += gbprintf(gb, "Dirty: ");
+     len += PrintVariables(gb, DirtyVars(node));
      return len;
 }
 
@@ -748,8 +753,8 @@
 		   TypeQual dl = NodeDeclLocation(node);
 		   TypeQual sc = NodeStorageClass(node);
 
-		   if ((dl == T_BLOCK_DECL || dl == T_FORMAL_DECL) &&
-		       (sc != T_TYPEDEF && sc != T_EXTERN && sc != T_STATIC) &&
+		   if ((tq_has_block_decl(dl) || tq_has_formal_decl(dl)) &&
+		       (!tq_has_typedef(sc) && !tq_has_extern(sc) && !tq_has_static(sc)) &&
 		       (IsScalarType(NodeDataType(node)) ||
 			IsPointerType(NodeDataType(node))))
 			vars = ConsItem(node, vars);
@@ -774,7 +779,8 @@
      /*  if ((node->typ != Proc) || strcmp(PhaseName, "Transform")) { KHR */
 
      /* don't look inside local procedures for register variables */
-     if (node->typ == Proc && DECL_LOCATION(node->u.proc.decl->u.decl.tq) != T_TOP_DECL)
+     if ((node->typ == Proc) &&
+	 !tq_has_top_decl(node->u.proc.decl->u.decl.tq))
 	  return vars;
 
 #define CODE(n)   vars = RegisterVariables(n, vars)
@@ -1021,7 +1027,7 @@
     node->nondeterminator = node->u.id.decl ? 
                      ((DeclIsExternal(node->u.id.decl) ||
 		       DeclIsStatic(node->u.id.decl)) &&
-		      (!(NodeDeclQuals(node->u.id.decl) & T_PRIVATE)) &&
+		      (!tq_has_private(NodeDeclTq(node->u.id.decl))) &&
 		      (!IsFunctionType(node->u.id.decl->u.decl.type)) &&
 		      (!HasNoCheckAttrib(node->u.id.decl->u.decl.attribs))) :
 			FALSE;
@@ -1082,8 +1088,8 @@
   switch (node->typ) {
   case Array:
     if (!((node->u.array.name->typ == Id) &&
-	  ((NodeDeclLocation(node->u.array.name->u.id.decl) == T_BLOCK_DECL) ||
-	   (NodeDeclQuals(node->u.array.name->u.id.decl) & T_PRIVATE)) &&
+	  (tq_has_block_decl(NodeDeclLocation(node->u.array.name->u.id.decl)) ||
+	   tq_has_private(NodeDeclTq(node->u.array.name->u.id.decl))) &&
 	  (IsArrayType(NodeDataType(node->u.array.name))))) {
       node->nondeterminator = TRUE;
       node->u.array.name->nondeterminator = FALSE;
@@ -1116,8 +1122,8 @@
     }
     else if (node->u.unary.op == INDIR) {
       if (!((node->u.unary.expr->typ == Id) &&
-	    ((NodeDeclLocation(node->u.unary.expr->u.id.decl) == T_BLOCK_DECL) ||
-	     (NodeDeclQuals(node->u.unary.expr->u.id.decl) & T_PRIVATE)) &&
+	    (tq_has_block_decl(NodeDeclLocation(node->u.unary.expr->u.id.decl)) ||
+	     tq_has_private(NodeDeclTq(node->u.unary.expr->u.id.decl))) &&
 	    (NodeDataType(node->u.unary.expr)->typ == Adcl))) {
 	node->nondeterminator = TRUE;
 	/* may need check expression
diff -Nur 5.4.2.2/cilk2c/ast.c current.Bug188/cilk2c/ast.c
--- 5.4.2.2/cilk2c/ast.c	2004-10-23 03:26:45.000000000 +0000
+++ current.Bug188/cilk2c/ast.c	2005-10-22 02:54:14.000000000 +0000
@@ -32,13 +32,18 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/ast.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/ast.c $ $LastChangedBy: bradley $ $Rev: 2538 $ $Date$");
 
 Coord UnknownCoord = { 
   /* line:   */ 0,
   /* offset: */ 0,
   /* file:   */	0
   };
+Coord DontPrintCoord = { 
+  /* line:   */ -2,
+  /* offset: */ -2,
+  /* file:   */	-2,
+  };
 
 /* use HeapNew() (defined in ast.h) to allocate whole objects */
 GLOBAL void *HeapAllocate(unsigned int number, unsigned int size)
@@ -1374,7 +1379,7 @@
     /* if from elaborated a struct/union's fields, new should not,
        since it's sharing */
     if (d == NodeOnly || d == Subtree)
-      NodeRemoveTq(new, T_SUE_ELABORATED);
+	NodeUpdateTq(new, tq_remove_sue_elaborated);
     break;
   case Spawn:          new->u.spawn.args = ListCopy(new->u.spawn.args);  break;
   case Asm:            new->u.Asm.output = ListCopy(new->u.Asm.output);  new->u.Asm.input = ListCopy(new->u.Asm.input);  new->u.Asm.clobbered = ListCopy(new->u.Asm.clobbered);  break;
@@ -1417,19 +1422,19 @@
 	      node->u.Block.right_coord = *c;
 	      break;
 	 case Sdcl:
-	      if (SUE_ELABORATED(node->u.sdcl.tq)) {
+	      if (tq_has_sue_elaborated(node->u.sdcl.tq)) {
 		   node->u.sdcl.type->coord = *c;
 		   node->u.sdcl.type->right_coord = *c;
 	      }
 	      break;
 	 case Udcl:
-	      if (SUE_ELABORATED(node->u.udcl.tq)) {
+	      if (tq_has_sue_elaborated(node->u.udcl.tq)) {
 		   node->u.udcl.type->coord = *c;
 		   node->u.udcl.type->right_coord = *c;
 	      }
 	      break;
 	 case Edcl:
-	      if (SUE_ELABORATED(node->u.edcl.tq)) {
+	      if (tq_has_sue_elaborated(node->u.edcl.tq)) {
 		   node->u.edcl.type->coord = *c;
 		   node->u.edcl.type->right_coord = *c;
 	      }
diff -Nur 5.4.2.2/cilk2c/ast.h current.Bug188/cilk2c/ast.h
--- 5.4.2.2/cilk2c/ast.h	2004-10-23 03:26:46.000000000 +0000
+++ current.Bug188/cilk2c/ast.h	2005-10-22 02:52:37.000000000 +0000
@@ -36,9 +36,10 @@
 #include "basics.h"
 #include "dataflow.h"
 #include "wildcard.h"
+#include "typequal.h"
 
 FILE_IDENTITY(ast_ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/ast.h $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/ast.h $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 /* definition of Node data structure */
 
@@ -86,142 +87,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-/* TypeQual: storage classes, type qualifiers, and additional attributes */
-
-typedef enum {
-
-     EMPTY_TQ = 0,
-/* 
-   Declaration qualifiers.  A declaration can have multiple qualifiers,
-   though some are mutually exclusive (like storage classes).
-   During the parsing of a declaration, decl qualifiers are kept in 
-   the tq field of its primitive type.  After the decl has been parsed,
-   SetDeclType then moves the qualifiers to their proper place, the 
-   Decl node.
-
-   To add a new decl qualifier:
-      1. Define a new symbol below, being careful that its bits do
-         not conflict with existing decl and type qualifiers,
-         since they can coexist in the same TypeQual variable.
-      2. Insert the symbol in T_DECL_QUALS (below).
-      3. If the qualifier is parsed in the source (rather than calculated),
-         add a lexical token (c4.l) and a new production to storage.classes
-         (ANSI-C.y).
-      4. Add code to print out its name in TQtoText (type.c).
-      5. Add merging logic to MergeTypeQuals (type.c), if necessary.
-*/
-
-  T_AUTO     = 0x00001,
-  T_EXTERN   = 0x00002,
-  T_REGISTER = 0x00003,
-  T_STATIC   = 0x00004,
-  T_TYPEDEF  = 0x00005,
-  /* Insert new storage classes here */
-
-  T_STORAGE_CLASSES = (T_AUTO | T_EXTERN | T_REGISTER | T_STATIC | T_TYPEDEF),
-#define STORAGE_CLASS(tq) ((tq) & T_STORAGE_CLASSES)
-
-  /* the following qualifiers are all mutually exclusive,
-     so they can share bits */
-  T_TOP_DECL    = 0x00010,   /* top-level decl */
-  T_BLOCK_DECL  = 0x00020,   /* local decl in a block */
-  T_FORMAL_DECL = 0x00030,   /* formal parameter decl */
-  T_SU_DECL     = 0x00040,   /* struct/union field decl */
-  T_ENUM_DECL   = 0x00050,   /* enumerated constant decl */
-  /* Insert new decl locations here */
-  
-  T_DECL_LOCATIONS = (T_TOP_DECL | T_BLOCK_DECL | T_FORMAL_DECL |
-		      T_SU_DECL | T_ENUM_DECL),
-#define DECL_LOCATION(tq)  ((tq) & T_DECL_LOCATIONS)
-
-     /* Flag for redundant external declaration, which is defined as
-      * an external declaration (NOT a definition, so it must have no
-      * initializer or function body) of a name previously declared external 
-      * in the same scope.  A trivial example:
-      *    extern int x;
-      *    extern int x;    <-- redundant
-      * But:
-      *    { extern int x; }
-      *    { extern int x; }  <-- not redundant
-      * because the two declarations have different scopes.
-      */
-     T_REDUNDANT_EXTERNAL_DECL = 0x00100,
-
-     /* Insert new decl qualifiers here */
-     T_SHARED           =   0x00200,
-     T_PRIVATE          =   0x00400,
-     T_NOOUTPUT         =   0x00800,	
-     T_CILKONLY         =   0x01000,	/* variable can only be used in cilk code */
-     T_CILKSAFE         =   0x02000,	/* promise that this variable is safe to access in parallel */
-
-     /* the following tq's are used to generate CILK_WHERE_AM_I directives */
-     T_FAST_PROCEDURE   =  0x04000,
-     T_SLOW_PROCEDURE   =  0x08000,
-     T_FAST_INLET       =  0x10000,
-     T_SLOW_INLET       =  0x20000,
-     T_STANDALONE_INLET =  0x40000,
-     T_C_CODE           =  0x80000,
-
-     T_CILK_WHERE_AM_I_DECL_QUALS  = (T_FAST_PROCEDURE | T_SLOW_PROCEDURE | T_FAST_INLET | T_SLOW_INLET | T_STANDALONE_INLET | T_C_CODE),
-
-     T_DECL_QUALS = (T_STORAGE_CLASSES | T_DECL_LOCATIONS 
-		     | T_REDUNDANT_EXTERNAL_DECL 
-		     | T_SHARED | T_PRIVATE | T_NOOUTPUT 
-		     | T_CILKONLY | T_CILKSAFE
-		     | T_CILK_WHERE_AM_I_DECL_QUALS
-		     ),
-
-#define DECL_QUALS(tq)    ((tq) & T_DECL_QUALS)
-
-
-/*
-   Type qualifiers.  Multiple type qualifiers may apply to a type.  
-   They may be associated with any primitive or complex type.  
-   Some type qualifiers may be moved after parsing -- for instance,
-   T_INLINE is moved to the top-level Fdcl it is describing.
-
-   To add a new type qualifier:
-      1. Define a new symbol below, being careful that its bits do
-         not conflict with existing storage classes and type qualifiers,
-         since they can coexist in the same TypeQual variable.
-      2. Insert the symbol in T_TYPE_QUALS (below).
-      3. Add a lexical token (c4.l) and a new production to either
-         type.qualifiers or pointer.type.qualifiers (ANSI-C.y), depending 
-         on whether the type qualifier is allowed only at the beginning
-         of a type, or can appear after '*' like const and volatile.
-      4. Add code to print out its name in TQtoText (type.c).
-      5. Add its symbol to TQ_ALWAYS_COMPATIBLE (below) if an object with
-         the type qualifier is always assignment-compatible with an object
-	 without the type qualifier.
-      6. Add merging logic to MergeTypeQuals (type.c), if necessary.
- */
-
-    T_RESTRICT = 0x100000,
-    T_COMPLEX  = 0x200000,
-
-    T_CONST    = 0x400000,   /* leave some room for new decl qualifiers */
-    T_VOLATILE = 0x800000,
-    T_INLINE   = 0x1000000,
-    T_SUE_ELABORATED  = 0x2000000,   /* on an Sdcl/Udcl/Edcl, indicates 
-				      whether SUE's field list appeared
-				      at that point in the source */
-#define SUE_ELABORATED(tq)   (((tq) & T_SUE_ELABORATED) != 0)
-    /* Insert new type qualifiers here */
-    T_PROCEDURE       = 0x4000000,
-
-    T_INLET           = 0x8000000,
-
-    T_EXTENSION       = 0x10000000, /* used for gcc __extension__ keyword.  Not exactly a TYPE_QUAL */
-
-    T_TYPE_QUALS = (T_RESTRICT | T_COMPLEX | T_CONST | T_VOLATILE | T_INLINE | T_SUE_ELABORATED | T_PROCEDURE | T_INLET ),
-#define TYPE_QUALS(tq)    ((tq) & T_TYPE_QUALS)
-    
-/* Type qualifiers listed in TQ_COMPATIBLE are ignored
- * when checking two types for compatibility (weaker than strict equality). */
-    TQ_COMPATIBLE   = (T_CONST | T_VOLATILE | T_INLINE | T_SUE_ELABORATED | T_RESTRICT | T_EXTENSION)
-
-} TypeQual;
-
+/* Type qualifiers, storage classes, and additional attributes now are found in typequal.h and typequal.c */
 
 
 /* BasicType covers all of the different fundamental types.
@@ -1009,9 +875,9 @@
  case Ptr:           if ((n)->u.ptr.type) {CODE((n)->u.ptr.type);} break; \
  case Adcl:          if ((n)->u.adcl.type) {CODE((n)->u.adcl.type);} if ((n)->u.adcl.dimp->dim) {CODE((n)->u.adcl.dimp->dim);} break; \
  case Fdcl:          if ((n)->u.fdcl.args) {LISTWALK((n)->u.fdcl.args, CODE);} if ((n)->u.fdcl.returns) {CODE((n)->u.fdcl.returns);} break; \
- case Sdcl:          if (SUE_ELABORATED((n)->u.sdcl.tq)) { if ((n)->u.sdcl.type->fields) {LISTWALK((n)->u.sdcl.type->fields, CODE);} if ((n)->u.sdcl.type->attributes) {LISTWALK((n)->u.sdcl.type->attributes, CODE);}} break; \
- case Udcl:          if (SUE_ELABORATED((n)->u.udcl.tq)) { if ((n)->u.udcl.type->fields) {LISTWALK((n)->u.udcl.type->fields, CODE);} if ((n)->u.udcl.type->attributes) {LISTWALK((n)->u.udcl.type->attributes, CODE);}} break; \
- case Edcl:          if (SUE_ELABORATED((n)->u.edcl.tq)) { if ((n)->u.edcl.type->fields) {LISTWALK((n)->u.edcl.type->fields, CODE);} if ((n)->u.edcl.type->attributes) {LISTWALK((n)->u.edcl.type->attributes, CODE);}} break; \
+ case Sdcl:          if (tq_has_sue_elaborated((n)->u.sdcl.tq)) { if ((n)->u.sdcl.type->fields) {LISTWALK((n)->u.sdcl.type->fields, CODE);} if ((n)->u.sdcl.type->attributes) {LISTWALK((n)->u.sdcl.type->attributes, CODE);}} break; \
+ case Udcl:          if (tq_has_sue_elaborated((n)->u.udcl.tq)) { if ((n)->u.udcl.type->fields) {LISTWALK((n)->u.udcl.type->fields, CODE);} if ((n)->u.udcl.type->attributes) {LISTWALK((n)->u.udcl.type->attributes, CODE);}} break; \
+ case Edcl:          if (tq_has_sue_elaborated((n)->u.edcl.tq)) { if ((n)->u.edcl.type->fields) {LISTWALK((n)->u.edcl.type->fields, CODE);} if ((n)->u.edcl.type->attributes) {LISTWALK((n)->u.edcl.type->attributes, CODE);}} break; \
  case Asm:	     if ((n)->u.Asm.template) {CODE((n)->u.Asm.template);} if ((n)->u.Asm.output) {LISTWALK((n)->u.Asm.output, CODE);} if ((n)->u.Asm.input) {LISTWALK((n)->u.Asm.input, CODE);} if ((n)->u.Asm.clobbered) {LISTWALK((n)->u.Asm.clobbered, CODE);} break; \
  case AsmArg:        if ((n)->u.AsmArg.constraint) {CODE((n)->u.AsmArg.constraint);} if ((n)->u.AsmArg.expr) {CODE((n)->u.AsmArg.expr);} break; \
 /* GCC builtin stdarg.h support */ \
@@ -1208,7 +1074,7 @@
 GLOBAL Node *NodeCopy(Node *from, TreeOpDepth d);
 GLOBAL Node *SetCoords(Node *tree, Coord c, TreeOpDepth d); /* Returns the modified node. */
 GLOBAL void WalkTree(Node *tree, WalkProc proc, void *ptr, WalkOrder order);
-GLOBAL void PrintCoord (FILE *out, Coord *c);
+GLOBAL void PrintCoord (GBUF *out, Coord *c);
 
 /* copy a list of nodes, using the TreeOpDepth to determine how to copy each node. */
 GLOBAL List *ListCopyNodes(List*, TreeOpDepth d);
diff -Nur 5.4.2.2/cilk2c/astEquals.c current.Bug188/cilk2c/astEquals.c
--- 5.4.2.2/cilk2c/astEquals.c	2004-10-23 03:26:44.000000000 +0000
+++ current.Bug188/cilk2c/astEquals.c	2005-10-22 02:52:37.000000000 +0000
@@ -275,44 +275,44 @@
 
 
 Bool EqualPrim(primNode *u1, primNode *u2) {
-  return ((u1->tq == u2->tq) && (u1->basic == u2->basic));
+  return (tq_equal(u1->tq, u2->tq) && (u1->basic == u2->basic));
 }
 
 
 
 Bool EqualTdef(tdefNode *u1, tdefNode *u2) {
   return ( EqualStrings(u1->name, u2->name)
-	   && (u1->tq == u2->tq));
+	   && tq_equal(u1->tq, u2->tq));
 }
 
 Bool EqualPtr(ptrNode *u1, ptrNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 
 Bool EqualAdcl(adclNode *u1, adclNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 Bool EqualFdcl(fdclNode *u1, fdclNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 Bool EqualSdcl(sdclNode *u1, sdclNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 Bool EqualUdcl(udclNode *u1, udclNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 Bool EqualEdcl(edclNode *u1, edclNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 
 Bool EqualDecl(declNode *u1, declNode *u2) {
-  return ((u1->tq == u2->tq)
+  return (tq_equal(u1->tq, u2->tq)
 	  && (EqualStrings(u1->name, u2->name)));
 }
 
@@ -333,7 +333,7 @@
 }
 
 Bool EqualAsm(asmNode *u1, asmNode *u2) {
-  return (u1->tq == u2->tq);
+  return tq_equal(u1->tq, u2->tq);
 }
 
 Bool EqualAsmArg(asmargNode *UNUSED(u1),
diff -Nur 5.4.2.2/cilk2c/astModify.h current.Bug188/cilk2c/astModify.h
--- 5.4.2.2/cilk2c/astModify.h	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/astModify.h	2005-10-22 02:52:37.000000000 +0000
@@ -321,15 +321,15 @@
                          {CODE((n1)->u.fdcl.returns, (n2)->u.fdcl.returns, answer);} \
                          break; \
      case Sdcl:          if (DUALWALKDEBUG) printf("Taking Sdcl branch... \n"); \
-                         if (SUE_ELABORATED((n1)->u.sdcl.tq) && SUE_ELABORATED((n2)->u.sdcl.tq)) \
+                         if (tq_has_sue_elaborated((n1)->u.sdcl.tq) && tq_has_sue_elaborated((n2)->u.sdcl.tq)) \
                           {DUAL_LIST_WALK((n1)->u.sdcl.type->fields, (n2)->u.sdcl.type->fields, answer, CODE, CONTINUE, FAILCODE);} \
                          break; \
      case Udcl:          if (DUALWALKDEBUG) printf("Taking Udcl branch... \n"); \
-                         if (SUE_ELABORATED((n1)->u.udcl.tq) && SUE_ELABORATED((n2)->u.udcl.tq)) \
+                         if (tq_has_sue_elaborated((n1)->u.udcl.tq) && tq_has_sue_elaborated((n2)->u.udcl.tq)) \
                            {DUAL_LIST_WALK((n1)->u.udcl.type->fields, (n2)->u.udcl.type->fields, answer, CODE, CONTINUE, FAILCODE);} \
                          break; \
      case Edcl:          if (DUALWALKDEBUG) printf("Taking Edcl branch... \n"); \
-                         if (SUE_ELABORATED((n1)->u.edcl.tq) && SUE_ELABORATED((n2)->u.edcl.tq)) \
+                         if (tq_has_sue_elaborated((n1)->u.edcl.tq) && tq_has_sue_elaborated((n2)->u.edcl.tq)) \
                            {DUAL_LIST_WALK((n1)->u.edcl.type->fields, (n2)->u.edcl.type->fields, answer, CODE, CONTINUE, FAILCODE);} \
                          break; \
      case Asm:	         {CODE((n1)->u.Asm.template, (n2)->u.Asm.template, answer);} \
@@ -504,13 +504,13 @@
      case Fdcl:          {LISTWALKTWO((n1)->u.fdcl.args, (n2), answer, CODE, CONTINUE, FAILCODE);} \
                          {CODE((n1)->u.fdcl.returns, (n2), answer);} \
                          break; \
-     case Sdcl:          if (SUE_ELABORATED((n1)->u.sdcl.tq))  \
+     case Sdcl:          if (tq_has_sue_elaborated((n1)->u.sdcl.tq))  \
                           {LISTWALKTWO((n1)->u.sdcl.type->fields, (n2), answer, CODE, CONTINUE, FAILCODE);} \
                          break; \
-     case Udcl:          if (SUE_ELABORATED((n1)->u.udcl.tq)) \
+     case Udcl:          if (tq_has_sue_elaborated((n1)->u.udcl.tq)) \
                            {LISTWALKTWO((n1)->u.udcl.type->fields, (n2), answer, CODE, CONTINUE, FAILCODE);} \
                          break; \
-     case Edcl:          if (SUE_ELABORATED((n1)->u.edcl.tq)) \
+     case Edcl:          if (tq_has_sue_elaborated((n1)->u.edcl.tq)) \
                            {LISTWALKTWO((n1)->u.edcl.type->fields, (n2), answer, CODE, CONTINUE, FAILCODE);} \
                          break; \
      case Asm:	         {CODE((n1)->u.Asm.template, (n2), answer);} \
diff -Nur 5.4.2.2/cilk2c/atmTransform.c current.Bug188/cilk2c/atmTransform.c
--- 5.4.2.2/cilk2c/atmTransform.c	2004-10-23 03:26:20.000000000 +0000
+++ current.Bug188/cilk2c/atmTransform.c	2005-10-22 02:52:37.000000000 +0000
@@ -568,7 +568,7 @@
   AtomicStartDepth = CurrentTableDepth+1;
   /*PrintNode(stdout, theDecl->u.decl.type, 0);*/
   if (theDecl != NULL) {
-    PrintNode(stdout, theDecl->u.decl.type, 0);
+    fPrintNode(stdout, theDecl->u.decl.type, 0);
     AddDeclsToTable(theDecl->u.decl.type->u.fdcl.args, CurrentTableDepth+1);
   }
   PrintSymbolTable(stdout, currentTable);
@@ -594,7 +594,7 @@
 
   if (copyType == NULL) {
     printf("Node is: \n");
-    PrintNode(stdout, node, 0);
+    fPrintNode(stdout, node, 0);
     printf("\n");
     FAIL("Binop node does not have type field filled in;");
   }
@@ -688,7 +688,7 @@
 
   if (node->u.id.decl == NULL) {
     printf("Node is: \n");
-    PrintNode(stdout, node, 0);
+    fPrintNode(stdout, node, 0);
     FAIL("Id node has no decl field. \n");
   }
   
diff -Nur 5.4.2.2/cilk2c/basics.h current.Bug188/cilk2c/basics.h
--- 5.4.2.2/cilk2c/basics.h	2004-10-23 03:26:20.000000000 +0000
+++ current.Bug188/cilk2c/basics.h	2005-10-22 02:54:14.000000000 +0000
@@ -32,7 +32,7 @@
 #define _BASICS_H_
 #include "../runtime/cilk-sysdep.h"
 FILE_IDENTITY(basics_ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/basics.h $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/basics.h $ $LastChangedBy: bradley $ $Rev: 2538 $ $Date$");
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -101,8 +101,9 @@
      short file;
 } Coord;
 
-GLOBAL extern Coord UnknownCoord;
+GLOBAL extern Coord UnknownCoord,DontPrintCoord;
 #define IsUnknownCoord(coord)  ((coord).file == UnknownCoord.file)
+#define IsDontPrintCoord(coord)  ((coord).file == DontPrintCoord.file)
 
 #define PRINT_COORD(out, c) \
     { if (PrintLineOffset) \
@@ -127,6 +128,7 @@
 #include "heap.h"
 #include "list.h"
 #include "symbol.h"
+#include "gbuf.h"
 
 /* Basic Global Variables */
 
@@ -172,15 +174,18 @@
 /* pretty-printing */
 GLOBAL void DPN(Node *n);
 GLOBAL void DPL(List *list);
-GLOBAL void PrintNode(FILE *out, Node *node, int tab_depth);
-GLOBAL int PrintConstant(FILE *out, Node *c, Bool with_name);
-GLOBAL void PrintCRSpaces(FILE *out, int spaces);
-GLOBAL void PrintSpaces(FILE *out, int spaces);
-GLOBAL void PrintList(FILE *out, List *list, int tab_depth);
-GLOBAL int PrintOp(FILE *out, OpType op);	/* operators.c */
+GLOBAL void PrintNode(GBUF *out, Node *node, int tab_depth);
+#define fPrintNode(file,node,tab_depth) WITH_FILE_GBUF(gb,file,PrintNode(gb,node,tab_depth))
+GLOBAL int  print_float(GBUF *, float);
+GLOBAL int  print_double(GBUF *, double);
+GLOBAL void PrintCRSpaces(GBUF *out, int spaces);
+GLOBAL void PrintSpaces(GBUF *out, int spaces);
+GLOBAL void PrintList(GBUF *out, List *list, int tab_depth);
+#define fPrintList(file,l,tab_depth) WITH_FILE_GBUF(gb,file,PrintList(gb,l,tab_depth))
+GLOBAL int PrintOp(GBUF *, OpType op);	/* operators.c */
 GLOBAL void CharToText(char *array, unsigned char value);
-GLOBAL inline int PrintChar(FILE *out, int c);	/* print.c */
-GLOBAL int PrintString(FILE *out, const char *string);	/* print.c */
+GLOBAL inline int PrintChar(GBUF *out, int c);	/* print.c */
+GLOBAL int PrintString(GBUF *out, const char *string);	/* print.c */
 
 /* warning.c */
 GLOBAL NoReturn(Fail(const char *file, int line, const char *msg));
@@ -226,4 +231,6 @@
 
 GLOBAL void OutputStmtList(FILE *outfile, List *myStmtList);
 
+GLOBAL void output_constant_to_GBUF(GBUF *, Node *, Bool /*with_name*/);
+GLOBAL void output_prim_type_to_GBUF(GBUF *gb, Node *type, char *lastc);
 #endif				/* ifndef _BASICS_H_ */
diff -Nur 5.4.2.2/cilk2c/c4.l current.Bug188/cilk2c/c4.l
--- 5.4.2.2/cilk2c/c4.l	2004-10-23 03:26:21.000000000 +0000
+++ current.Bug188/cilk2c/c4.l	2005-10-22 02:52:37.000000000 +0000
@@ -168,7 +168,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/c4.l $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/c4.l $ $LastChangedBy: bradley $ $Rev: 1880 $ $Date$");
 
 PRIVATE inline void GetCoord(Coord *pcoord);
 PRIVATE Node *char_constant(const char *);
@@ -906,7 +906,7 @@
     if (input_language) {
 	return strcmp(input_language, "cilk")==0;
     } else {
-	return HasSuffix(name, ".cilk") || HasSuffix(name, ".cilkh") || HasSuffix(name, "cilki");
+	return HasSuffix(name, ".cilk") || HasSuffix(name, ".cilkp") || HasSuffix(name, ".cilkh") || HasSuffix(name, "cilki");
     }
 }
 
@@ -953,7 +953,7 @@
 		     * non-includable file included from includable
 		     * file.  Issue a warning.
 		     */
-		    printf("%s hash_cilk_suffix=%d\n", name, Has_Cilk_Suffix(name, input_language));
+		    printf("%s:%d %s Has_Cilk_Suffix=%d\n", __FILE__, __LINE__, name, Has_Cilk_Suffix(name, input_language));
 		    Warning(1,
 			    "Non-includable file %s included from includable"
 			    " file %s.", name, FileNames[CurrentFile]);
diff -Nur 5.4.2.2/cilk2c/complex-types.c current.Bug188/cilk2c/complex-types.c
--- 5.4.2.2/cilk2c/complex-types.c	2004-10-23 03:26:20.000000000 +0000
+++ current.Bug188/cilk2c/complex-types.c	2005-10-22 02:54:14.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/complex-types.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/complex-types.c $ $LastChangedBy: bradley $ $Rev: 2540 $ $Date$");
 
      /* From ANSI-C.y */
 GLOBAL Bool OmitLookups();
@@ -87,7 +87,7 @@
 	    continue;
 	  default:
 	    Warning(1, "Internal Error!: invalid `complex' arg\n");
-	    PrintNode(stderr, complex, 0);
+	    DPN(complex);
 	    fprintf(stderr, "\n");
 	    exit(1);
 	    return(complex);  /* unreachable */
@@ -238,9 +238,9 @@
     Node *var;
 
 #if 0
-    printf("\nSetDeclType(decl, type, %d)\n", redeclare);
-    PrintNode(stdout, decl, 0); printf("\n");
-    PrintNode(stdout, type, 0); printf("\n");
+    printf("\n%s:%d SetDeclType(decl, type, %d)\n", __FILE__, __LINE__, redeclare);
+    DPN(decl);
+    DPN(type);
 #endif
 
     assert(decl != NULL && decl->typ == Decl);
@@ -266,9 +266,12 @@
   storage classes to Decl node, and inserting it in the
   symbol table.
 
+  Also move attributes up to the decl.
+
 ********************************************************/
 
     decl = FinishDecl(decl);
+    //printf("%s:%d ", __FILE__, __LINE__); DPN(decl);
     sc = NodeStorageClass(decl);
 
     if (OldStyleFunctionDefinition) {
@@ -277,7 +280,7 @@
 	if (redeclare != SU) redeclare = Formal;
     }
 
-    if (sc == T_TYPEDEF) {
+    if (tq_has_typedef(sc)) {
       var = decl;
     } else if (decl->u.decl.type->typ == Fdcl && (redeclare != Formal)) {
 
@@ -308,7 +311,7 @@
 						    decl,
 						    (ConflictProc) FunctionConflict));
       
-    } else if (sc == T_EXTERN ||
+    } else if (tq_has_extern(sc) ||
 	       (Level == 0  &&  redeclare == Redecl)) {
       /* top-level variable, check for consistency with Externals */
       var = (OmitLookups() ? decl : InsertSymbol(Externals,
@@ -330,7 +333,7 @@
 	/* decl could be redundant, but we don't know if it's a 
 	   definition or declaration yet.  Mark it, and let SetDeclInit
 	   decide. */
-	NodeAddTq(decl, T_REDUNDANT_EXTERNAL_DECL);
+	NodeUpdateTq(decl, tq_add_redundant_external_decl);
     }
 
     switch (redeclare) {
@@ -342,7 +345,7 @@
 	}
 	/* falls through to Redecl */
       case Redecl:
-	NodeSetDeclLocation(decl, Level == 0 ? T_TOP_DECL : T_BLOCK_DECL);
+	NodeSetDeclLocation(decl, Level == 0 ? TQ_TOP_DECL : TQ_BLOCK_DECL);
 
 	/* add to current scope */
 	if (!OmitLookups()) {
@@ -351,20 +354,20 @@
 	}
 	break;
       case SU:
-	NodeSetDeclLocation(decl, T_SU_DECL);
+	NodeSetDeclLocation(decl, TQ_SU_DECL);
 
 	/* each struct/union has it own namespace for fields */
 	break;
       case Formal:
-	NodeSetDeclLocation(decl, T_FORMAL_DECL);
+	NodeSetDeclLocation(decl, TQ_FORMAL_DECL);
 
-	if (sc != 0  &&  sc != T_REGISTER) {
+	if (tq_has_anything(sc) && !tq_has_register(sc)) {
 	    SyntaxErrorCoord(decl->coord,
 			     "illegal storage class for parameter `%s'",
 			     decl->u.decl.name);
-	    if (sc == T_TYPEDEF) break;
+	    if (tq_has_typedef(sc)) break;
 	    /* reset storage class for body */
-	    NodeSetStorageClass(decl, 0);
+	    NodeSetStorageClass(decl, EMPTY_TQ);
 	}
 
 	/* convert Adcl to pointer */
@@ -386,6 +389,10 @@
 	      before the body is parsed. */
 	break;
     }
+#if 0
+    printf("\n%s:%d SetDeclType returns\n", __FILE__, __LINE__);
+    DPN(decl);
+#endif
     return(decl);
 }
 
@@ -396,13 +403,11 @@
     assert(decl->u.decl.init == NULL);
     decl->u.decl.init = init;
 
-
     if (init) {
-      if (NodeTq(decl) & T_REDUNDANT_EXTERNAL_DECL)
+      if (tq_has_redundant_external_decl(NodeTq(decl)))
 	/* fix up misprediction made in SetDeclType.  
 	   decl has an initializer, so it isn't redundant. */
-	NodeRemoveTq(decl, T_REDUNDANT_EXTERNAL_DECL);
-      
+	  NodeUpdateTq(decl, tq_remove_redundant_external_decl);
     }
 
     return(decl);
@@ -419,8 +424,11 @@
 GLOBAL Node *SetDeclAttribs(Node *decl, List *attribs)
 {
      assert(decl != NULL && decl->typ == Decl);
-     assert(decl->u.decl.attribs == NULL);
-     decl->u.decl.attribs = attribs;
+     assert(decl->u.decl.tq.attributes==NULL); // We don't store any attributes in the tq at this point. */
+     //printf("%s:%d: ", __FILE__, __LINE__); DPN(decl);
+     decl->u.decl.attribs = JoinLists(decl->u.decl.attribs, attribs);
+     //printf("%s:%d: ", __FILE__, __LINE__); DPN(decl);
+     //printf("%s:%d: ", __FILE__, __LINE__); DPL(decl->u.decl.attribs);
      return (decl);
 }
 
@@ -447,6 +455,8 @@
 
    WARNING:  FinishDecl may be run more than once on a decl, so it
    should not blindly make unnecessary changes.
+
+   Move attributes up as well as storage class.
 */
 GLOBAL Node *FinishDecl(Node *decl)
 {
@@ -460,14 +470,18 @@
 
   /* move decl qualifiers to decl */
   tq = NodeTq(deepbasetype);
-  NodeRemoveTq(deepbasetype, T_DECL_QUALS);
-  NodeAddTq(decl, DECL_QUALS(tq));
+  //printf("%s:%d deepbasetype is (are attributes there?)", __FILE__, __LINE__); DPN(deepbasetype);
+  NodeUpdateTq(deepbasetype, tq_remove_all_decl_quals);
+  //printf("%s:%d deepbasetype is (are attributes there?)", __FILE__, __LINE__); DPN(deepbasetype);
+  NodeUpdateTq2(decl, tq_union, (TypeQual){tq_decl_quals(tq).tq,0});
+  decl->u.decl.attribs = JoinLists(decl->u.decl.attribs, tq_decl_quals(tq).attributes);
+  //printf("%s:%d decl is (are attributes there?)", __FILE__, __LINE__); DPN(decl);
   minf_coord(&decl->coord, &deepbasetype->coord); /* when we move type qualifers around, we also need to note that the position of the declaration may have moved to an earlier spot. */
 
   /* check for incomplete struct/union/enum -- only if not typedef and
      not definition */
   sc = NodeStorageClass(decl);
-  if (sc != T_TYPEDEF && !(sc == T_EXTERN && !decl->u.decl.init))
+  if (!tq_has_typedef(sc) && !(tq_has_extern(sc) && !decl->u.decl.init))
     VerifySUEcomplete(decl->u.decl.type);
   
   return decl;
@@ -489,41 +503,41 @@
   Node *deepbasetype = GetDeepBaseType(type);
   TypeQual basetq = NodeTq(deepbasetype);
 
-  if (basetq & T_INLINE) {
+  if (tq_has_inline(basetq)) {
     if (ANSIOnly)
       SyntaxError("inline keyword not allowed with -ansi switch");
     else if (!IsFunctionType(type))
       WarningCoord(1, type->coord, 
 		   "inline qualifier applies only to functions");
-    else NodeAddTq(type, T_INLINE);
-    NodeRemoveTq(deepbasetype, T_INLINE);
+    else NodeUpdateTq(type, tq_add_inline);
+    NodeUpdateTq(deepbasetype, tq_remove_inline);
     minf_coord(&type->coord, &deepbasetype->coord); /* when we move type qualifers around, we also need to note that the position of the declaration may have moved to an earlier spot. */
   }
 
   /* Insert your extensions here */
-  if (basetq & T_PROCEDURE) {
+  if (tq_has_procedure(basetq)) {
     if (!IsFunctionType(type))
       {
 	if (!IsPtrToFunction(type))
 	  SyntaxErrorCoord(deepbasetype->coord, 
 			   "cilk keyword applies only to functions");
 	else
-	  NodeAddTq(type->u.ptr.type, T_PROCEDURE);
+	  NodeUpdateTq(type->u.ptr.type, tq_add_procedure);
       }
-    else NodeAddTq(type, T_PROCEDURE);
-    NodeRemoveTq(deepbasetype, T_PROCEDURE);
+    else NodeUpdateTq(type, tq_add_procedure);
+    NodeUpdateTq(deepbasetype, tq_remove_procedure);
   }
-  if (basetq & T_INLET) {
+  if (tq_has_inlet(basetq)) {
     if (!IsFunctionType(type))
       {
 	if (!IsPtrToFunction(type))
 	  SyntaxErrorCoord(deepbasetype->coord, 
 			   "inlet keyword applies only to functions");
 	else
-	  NodeAddTq(type->u.ptr.type, T_INLET);
+	  NodeUpdateTq(type->u.ptr.type, tq_add_inlet);
       }
-    else NodeAddTq(type, T_INLET);
-    NodeRemoveTq(deepbasetype, T_INLET);
+    else NodeUpdateTq(type, tq_add_inlet);
+    NodeUpdateTq(deepbasetype, tq_remove_inlet);
   }
 
   return type;
@@ -550,18 +564,8 @@
 
     type = NodeCopy(GetDeepBaseType(firstdecl->u.decl.type), NodeOnly);
 
-    decl->u.decl.tq |= firstdecl->u.decl.tq;
+    decl->u.decl.tq = tq_union(decl->u.decl.tq, firstdecl->u.decl.tq);
     AppendItem(list, SetDeclType(decl, type, redeclare));
 
     return(list);
 }
-
-
-
-
-
-
-
-
-
-
diff -Nur 5.4.2.2/cilk2c/config.h current.Bug188/cilk2c/config.h
--- 5.4.2.2/cilk2c/config.h	2004-10-23 03:26:20.000000000 +0000
+++ current.Bug188/cilk2c/config.h	2005-10-22 02:52:37.000000000 +0000
@@ -27,7 +27,7 @@
 #define _CONFIG_H_
 
 FILE_IDENTITY(config_ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/config.h $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/config.h $ $LastChangedBy: bradley $ $Rev: 1341 $ $Date$");
 
 #include <limits.h>
 
diff -Nur 5.4.2.2/cilk2c/constexpr.c current.Bug188/cilk2c/constexpr.c
--- 5.4.2.2/cilk2c/constexpr.c	2004-10-23 03:26:42.000000000 +0000
+++ current.Bug188/cilk2c/constexpr.c	2005-10-22 02:52:37.000000000 +0000
@@ -29,7 +29,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/constexpr.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/constexpr.c $ $LastChangedBy: bradley $ $Rev: 1341 $ $Date$");
 
 
 PRIVATE BasicType BasicTypeOfConstantValue(Node *type);
diff -Nur 5.4.2.2/cilk2c/container.c current.Bug188/cilk2c/container.c
--- 5.4.2.2/cilk2c/container.c	2004-10-23 03:26:45.000000000 +0000
+++ current.Bug188/cilk2c/container.c	2005-10-22 02:52:38.000000000 +0000
@@ -29,7 +29,7 @@
 
 #include "ast.h"
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/container.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/container.c $ $LastChangedBy: bradley $ $Rev: 1341 $ $Date$");
 
 typedef struct {
      NodeType typ;
diff -Nur 5.4.2.2/cilk2c/conversions.c current.Bug188/cilk2c/conversions.c
--- 5.4.2.2/cilk2c/conversions.c	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/conversions.c	2005-10-22 02:52:37.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/conversions.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/conversions.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 #include "conversions.h"
 
@@ -476,9 +476,9 @@
 			    return;
 		       default:
 			    printf("Unrecognized to type\n");
-			    PrintNode(stdout, *node2p, 0);
+			    DPN(*node2p);
 			    printf("\n");
-			    PrintNode(stdout, type2, 0);
+			    DPN(type2);
 			    printf("\n");
 			    assert(FALSE);
 		   }
@@ -512,17 +512,17 @@
 			    return;
 		       default:
 			    printf("Unrecognized to type\n");
-			    PrintNode(stdout, *node2p, 0);
+			    DPN(*node2p);
 			    printf("\n");
-			    PrintNode(stdout, type2, 0);
+			    DPN(type2);
 			    printf("\n");
 			    assert(FALSE);
 		   }
 	      default:
 		   printf("Unrecognized from type\n");
-		   PrintNode(stdout, *node1p, 0);
+		   DPN(*node1p);
 		   printf("\n");
-		   PrintNode(stdout, type1, 0);
+		   DPN(type1);
 		   printf("\n");
 		   assert(FALSE);
 	  }
@@ -884,11 +884,16 @@
       * absence of const or volatile in the right operand."  So
       * qualifiers on left must include all qualifiers on right.  
       */
-     TypeQual lcv = NodeTypeQuals(ltype) & (T_CONST | T_VOLATILE | T_RESTRICT),
-	  rcv = NodeTypeQuals(rtype) & (T_CONST | T_VOLATILE | T_RESTRICT);
-
-     if ((lcv | rcv) != lcv)
-	  return FALSE;
+    if ((!tq_has_const(NodeTq(ltype)))    && tq_has_const(NodeTq(rtype))) return FALSE;
+    if ((!tq_has_volatile(NodeTq(ltype))) && tq_has_volatile(NodeTq(rtype))) return FALSE;
+    if ((!tq_has_restrict(NodeTq(ltype))) && tq_has_restrict(NodeTq(rtype))) return FALSE;
+/* OLD CODE TO DO THAT:  I Personally find the new code (above) to be much easier to read.  -Bradley
+ *    TypeQual lcv = NodeTypeQuals(ltype) & (T_CONST | T_VOLATILE | T_RESTRICT),
+ *             rcv = NodeTypeQuals(rtype) & (T_CONST | T_VOLATILE | T_RESTRICT);
+ *
+ *    if ((lcv | rcv) != lcv)
+ *       return FALSE;
+*/
 
      /*
       * type qualifiers okay at top-level; remove them and test
diff -Nur 5.4.2.2/cilk2c/conversions.h current.Bug188/cilk2c/conversions.h
--- 5.4.2.2/cilk2c/conversions.h	2004-10-23 03:26:20.000000000 +0000
+++ current.Bug188/cilk2c/conversions.h	2005-10-22 02:52:37.000000000 +0000
@@ -30,7 +30,7 @@
 #ifndef _CONVERSIONS_H_
 #define _CONVERSIONS_H_
 FILE_IDENTITY(conversions_h_ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/conversions.h $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/conversions.h $ $LastChangedBy: bradley $ $Rev: 1341 $ $Date$");
 
 
 GLOBAL Node *UsualUnaryConversions(Node *node, Bool f_to_d);
diff -Nur 5.4.2.2/cilk2c/dataflow.h current.Bug188/cilk2c/dataflow.h
--- 5.4.2.2/cilk2c/dataflow.h	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/dataflow.h	2005-10-22 02:52:37.000000000 +0000
@@ -30,7 +30,7 @@
 #define _DATAFLOW_H_
 
 FILE_IDENTITY(dataflow_h_ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/dataflow.h $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/dataflow.h $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 typedef unsigned long BitVector;
 #define MAX_BITVECTOR_LENGTH    (sizeof(BitVector) * CHAR_BIT)
@@ -81,8 +81,8 @@
 GLOBAL List *RegisterVariables(Node *node, List *vars);
 
 GLOBAL void PV(List *vars);
-GLOBAL int PrintVariables(FILE *out, List *vars);
-GLOBAL int PrintAnalysis(FILE *out, Node *node);
+GLOBAL int PrintVariables(GBUF *,List *vars);
+GLOBAL int PrintAnalysis(GBUF *,Node *node);
 
 GLOBAL void AnalyzeLiveVariables(Node *root, List *vars);
 GLOBAL void AnalyzeReturnFlow(Node *root);
diff -Nur 5.4.2.2/cilk2c/elide.c current.Bug188/cilk2c/elide.c
--- 5.4.2.2/cilk2c/elide.c	2004-10-23 03:26:42.000000000 +0000
+++ current.Bug188/cilk2c/elide.c	2005-10-22 02:52:38.000000000 +0000
@@ -21,7 +21,7 @@
 #include <ast.h>
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/elide.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/elide.c $ $LastChangedBy: bradley $ $Rev: 2448 $ $Date$");
 
     
 PRIVATE Node *ElideNode(Node *node);
@@ -245,9 +245,7 @@
      u->args = ElideList(u->args);
      u->returns = ElideNode(u->returns);
 
-     if (u->tq & T_PROCEDURE) {
-	 u->tq &= ~T_PROCEDURE; /* Get rid of the cilk keyword*/
-     }
+     u->tq = tq_remove_procedure(u->tq); /* Get rid of the cilk keyword*/
 
      return node;
 }
@@ -375,7 +373,7 @@
     assert(decl->typ == Decl);
     fdcl = decl->u.decl.type;
     assert(fdcl->typ == Fdcl);
-    fdcl->u.fdcl.tq &= ~(T_INLET | T_PROCEDURE  | T_CILK_WHERE_AM_I_DECL_QUALS);
+    fdcl->u.fdcl.tq = tq_remove_inlet(tq_remove_procedure(tq_remove_cilk_where_am_i_decl_quals(fdcl->u.fdcl.tq)));
     
     u->decl = ElideNode(u->decl);
     u->body = ElideNode(u->body);
@@ -406,10 +404,10 @@
     if (!node)
 	return NULL;
     
+    /* Get rid of cilk keyword. */
     if (node->typ == Proc &&
-	node->u.proc.decl->u.decl.type->typ == Fdcl &&
-	node->u.proc.decl->u.decl.type->u.fdcl.tq & T_PROCEDURE) {
-	node->u.proc.decl->u.decl.type->u.fdcl.tq &= ~T_PROCEDURE;
+	node->u.proc.decl->u.decl.type->typ == Fdcl) {
+	node->u.proc.decl->u.decl.type->u.fdcl.tq = tq_remove_procedure(node->u.proc.decl->u.decl.type->u.fdcl.tq);
     }
     result = List1(ElideNode(node));
     
diff -Nur 5.4.2.2/cilk2c/gbuf.c current.Bug188/cilk2c/gbuf.c
--- 5.4.2.2/cilk2c/gbuf.c	1970-01-01 00:00:00.000000000 +0000
+++ current.Bug188/cilk2c/gbuf.c	2005-10-22 02:52:37.000000000 +0000
@@ -0,0 +1,103 @@
+#include <basics.h>
+//#include <assert.h>
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
+
+GLOBAL int gbprintf(GBUF *gb, const char *format, ...) {
+    int r;
+    va_list ap;
+    va_start(ap, format);
+    r=gb->vfprintf_fun(gb->state, format, ap);
+    va_end(ap);
+    return r;
+}
+GLOBAL int gbputs (const char *string, GBUF *gb) {
+    return gb->fputs_fun(string, gb->state);
+}
+
+/*********************************************
+ * functions for creating output to a string.
+ *********************************************/
+
+struct mbuffer {
+    char *string;
+    char *tail;
+    int  n_chars_left; /* Number of characters left in the buffer (including the tailing \0) */
+};
+
+PRIVATE void init_mbuffer (char *array, int arraysize, struct mbuffer *b) {
+    b->string=array;
+    b->tail  =array;
+    assert(arraysize>0);
+    b->n_chars_left=arraysize;
+    array[0]=0;
+}
+
+/* Act like fputs. */
+PRIVATE int add_string_to_mbuffer(const char *string, void *state) {
+    struct mbuffer *b=state;
+    int l = strlen(string);
+    if (l+1>b->n_chars_left) return -1;
+    strcpy(b->tail, string); /* Don't use strncpy, because that fills in the whole tail of the dest with nulls. Slow and error prone. */
+    b->tail+=l;
+    b->n_chars_left-=l;
+    return l;
+}
+
+PRIVATE void free_mbuffer (void *s) {
+    free(s);
+}
+
+GLOBAL int vfprintf_to_mbuffer (void *state, const char *format, va_list ap) {
+    struct mbuffer *mb = state;
+    int    oldavail  = mb->n_chars_left;
+    int    n_written = vsnprintf(mb->tail, oldavail, format, ap);
+    if (n_written>=oldavail || n_written<0) {
+	mb->tail[oldavail-1]=0;
+	mb->tail+=oldavail;
+	mb->n_chars_left=0;
+	return -1;
+    } else {
+	mb->tail+=n_written;
+	mb->n_chars_left-=n_written;
+	return n_written;
+    }
+}
+
+
+GLOBAL GBUF* make_string_gbuf (char *array, int arraysize) {
+    GBUF *result = malloc(sizeof(*result));
+    struct mbuffer *mb = malloc(sizeof(*mb));
+    result->state = mb;
+    result->fputs_fun = add_string_to_mbuffer;
+    result->vfprintf_fun = vfprintf_to_mbuffer;
+    result->free_state_fun = free_mbuffer;
+    init_mbuffer(array, arraysize, mb);
+    return result;
+}
+
+PRIVATE int add_string_to_file (const char *string, void *state) {
+    FILE *f=state;
+    return fputs(string, f);
+}
+
+PRIVATE int vfprintf_to_file (void *state, const char *format, va_list ap) {
+    FILE *stream=state;
+    return vfprintf(stream, format, ap);
+}
+
+GLOBAL GBUF* make_file_gbuf (FILE *f) {
+    GBUF *result = malloc(sizeof(*result));
+    result->state = f;
+    result->fputs_fun = add_string_to_file;
+    result->vfprintf_fun = vfprintf_to_file;
+    result->free_state_fun = 0;
+    return result;
+}
+
+GLOBAL void free_gbuf (GBUF *gb) {
+    if (gb->free_state_fun) gb->free_state_fun(gb->state);
+    free(gb);
+}
+
diff -Nur 5.4.2.2/cilk2c/gbuf.h current.Bug188/cilk2c/gbuf.h
--- 5.4.2.2/cilk2c/gbuf.h	1970-01-01 00:00:00.000000000 +0000
+++ current.Bug188/cilk2c/gbuf.h	2005-10-22 02:52:37.000000000 +0000
@@ -0,0 +1,18 @@
+#include <stdarg.h>
+#include <stdio.h>
+
+typedef struct generalized_buffer {
+    void *state;
+    int (*fputs_fun)(const char *string, void *state);
+    int (*vfprintf_fun)(void *state, const char *format, va_list);
+    void (*free_state_fun)(void*);
+} GBUF;
+
+GLOBAL int gbprintf(GBUF *gb, const char *format, ...) __attribute__((format (printf, 2, 3)));
+GLOBAL int gbputs (const char *string, GBUF *gb);     
+
+GLOBAL GBUF* make_string_gbuf (char *array, int arraysize);
+GLOBAL GBUF* make_file_gbuf (FILE *f);
+GLOBAL void  free_gbuf(GBUF*);
+
+#define WITH_FILE_GBUF(gb,file,stmt) ({ GBUF *gb = make_file_gbuf(file); stmt; free_gbuf(gb); })
diff -Nur 5.4.2.2/cilk2c/hint.c current.Bug188/cilk2c/hint.c
--- 5.4.2.2/cilk2c/hint.c	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/hint.c	2005-10-22 02:52:37.000000000 +0000
@@ -38,7 +38,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/hint.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/hint.c $ $LastChangedBy: bradley $ $Rev: 2454 $ $Date$");
 
 
 PRIVATE Node *HintNode(Node *node);
@@ -349,7 +349,7 @@
      u->asmdecl = HintNode(u->asmdecl);
 
      /* global variables are a bad idea, especially in Cilk */
-     if (!(NodeStorageClass(node) == T_EXTERN) &&
+     if (!tq_has_extern(NodeStorageClass(node)) &&
 	 IsTroublesomeDeclaration(node)) {
 	  HintCoord(node->coord,
 		    "declaration of global variable `%s'", u->name);
@@ -418,10 +418,10 @@
      assert(node->typ = Decl);
 
      type = NodeDataTypeSuperior(node);
-     return (((NodeDeclLocation(node) == T_TOP_DECL) 
-	      || (NodeTq(node) == T_STATIC)) 
+     return ((tq_has_top_decl(NodeDeclLocation(node))
+	      || tq_has_static(NodeTq(node))) 
 	     &&
-	     !(NodeTq(node) & T_CILKSAFE) &&
+	     !tq_has_cilksafe(NodeTq(node)) &&
 	     !(NodeIsConstQual(type)) &&
 	     !(NodeIsConstQual(GetShallowBaseType(type))) &&
 	     !DeclIsTypedef(node) && 
diff -Nur 5.4.2.2/cilk2c/initializer.c current.Bug188/cilk2c/initializer.c
--- 5.4.2.2/cilk2c/initializer.c	2004-10-23 03:26:42.000000000 +0000
+++ current.Bug188/cilk2c/initializer.c	2005-10-22 02:52:38.000000000 +0000
@@ -30,7 +30,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/initializer.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/initializer.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 #include "conversions.h"
 #include "initializer.h"
@@ -327,7 +327,7 @@
 	  SyntaxErrorCoord(decl->coord,
 			   "Expression cannot have an initializer \"%s\"",
 			   decl->u.decl.name);
-	  PrintNode(stdout, dtype, 0);
+	  DPN(dtype);
 	  printf("\n");
 	  return NULL;
      }
diff -Nur 5.4.2.2/cilk2c/main.c current.Bug188/cilk2c/main.c
--- 5.4.2.2/cilk2c/main.c	2004-10-23 03:26:45.000000000 +0000
+++ current.Bug188/cilk2c/main.c	2005-10-22 02:52:38.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/main.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/main.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 #include <errno.h>
 #include "stringParse.h"
@@ -614,7 +614,7 @@
 		       PLURAL(Warnings));
      }
      if (PrintAST) {
-	  PrintList(stdout, Program, -1);
+	  fPrintList(stdout, Program, -1);
 	  fprintf(stdout, "\n");
      }
      /* cleanup */
diff -Nur 5.4.2.2/cilk2c/operators.c current.Bug188/cilk2c/operators.c
--- 5.4.2.2/cilk2c/operators.c	2004-10-23 03:26:45.000000000 +0000
+++ current.Bug188/cilk2c/operators.c	2005-10-22 02:52:38.000000000 +0000
@@ -29,7 +29,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/operators.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/operators.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 
 GLOBAL OpEntry Operator[MAX_OPERATORS];
@@ -158,7 +158,7 @@
      return Operator[op].text;
 }
 
-GLOBAL int PrintOp(FILE *out, OpType op)
+GLOBAL int PrintOp(GBUF *gb, OpType op)
 {
      OpEntry *operator = &Operator[op];
 
@@ -168,8 +168,9 @@
 	  fprintf(stderr, "unknown operator %d\n", op);
 	  FAIL("");
      }
-     fputs(operator->text, out);
+     gbputs(operator->text, gb);
      return strlen(operator->text);
+   
 }
 
 GLOBAL int OpPrecedence(NodeType typ, OpType op, Bool *left_assoc)
diff -Nur 5.4.2.2/cilk2c/output.c current.Bug188/cilk2c/output.c
--- 5.4.2.2/cilk2c/output.c	2004-10-23 03:26:18.000000000 +0000
+++ current.Bug188/cilk2c/output.c	2005-10-22 02:54:14.000000000 +0000
@@ -187,7 +187,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/output.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/output.c $ $LastChangedBy: bradley $ $Rev: 2540 $ $Date$");
 
 #include <ctype.h>
 
@@ -207,10 +207,10 @@
 
 typedef struct {
      char prev_char;            /* what is the previous character written?  Use this to determine if whitespace may need to be added. */
-     FILE *f;
      Coord curr;
      int block;
      int block_indents[MAX_NESTED_SCOPES];
+     GBUF *gb;
 } OutputContext;
 
 PRIVATE void SetOutputCoord(OutputContext *out, Coord *pcoord);
@@ -229,6 +229,9 @@
 PRIVATE Bool IsSourceExpression(Node *node);
 PRIVATE int Precedence(Node *node, Bool *left_assoc);
 
+PRIVATE void output_prim_type (OutputContext *out, Node *type, char *lastc, Bool print_coords);
+PRIVATE void OutputTQ (OutputContext *out, TypeQual tq, Coord *coord);
+
 PRIVATE void OutputExpr(OutputContext *out, Node *node);
 PRIVATE void OutputInnerExpr(OutputContext *out, Node *node, int enclosing_precedence, Context context);
 PRIVATE void OutputPartialType(OutputContext *out, Context context,
@@ -240,14 +243,14 @@
 PRIVATE void OutputAsmDecl(OutputContext *out, Node *a);
 PRIVATE int OutputDecl(OutputContext *out, DeclKind k, Node *node);
 PRIVATE void OutputDeclList(OutputContext *out, DeclKind k, List *lst);
-PRIVATE void OutputSUE(OutputContext *out, SUEtype *sue, Bool elaboratedp);
+PRIVATE void OutputSUE(OutputContext *out, SUEtype *sue, Bool elaboratedp, List *attributes);
 PRIVATE void OutputTextNode(OutputContext *out, Node *node);
 
 GLOBAL void OutputProgram(FILE *outfile, List *program)
 {
      OutputContext out;
 
-     out.f = outfile;
+     out.gb = make_file_gbuf(outfile);
      out.curr = UnknownCoord;
      out.block = 0;
      out.block_indents[0] = 0;
@@ -255,6 +258,7 @@
 
      OutputDeclList(&out, TopDecl, program);
      OutCh(&out, '\n');
+     free_gbuf(out.gb);
 }
 
 /** This was added to work with parsing from a string.
@@ -263,7 +267,7 @@
 GLOBAL void OutputStmtList(FILE *outfile, List *myStmtList)
 {
      OutputContext out;
-     out.f = outfile;
+     out.gb = make_file_gbuf(outfile);
      out.curr = UnknownCoord;
      out.block = 0;
      out.block_indents[0] = 0;
@@ -281,7 +285,7 @@
 
 PRIVATE void SetOutputCoord(OutputContext *out, Coord *pcoord)
 {
-     if (IsUnknownCoord(*pcoord))
+     if (IsUnknownCoord(*pcoord) || IsDontPrintCoord(out->curr))
 	  return;		/* *pcoord == UnknownCoord, so ignore */
 
      /* First, set line */
@@ -289,8 +293,8 @@
 	  if (out->curr.offset != 0)
 	       OutNewLine(out);
 	  if (!FormatReadably)
-	       fprintf(out->f, "# %d \"%s\"\n", pcoord->line,
-		       FileNames[pcoord->file]);
+	       gbprintf(out->gb, "# %d \"%s\"\n", pcoord->line,
+			FileNames[pcoord->file]);
 	  out->curr.file = pcoord->file;
 	  out->curr.line = pcoord->line;
 	  out->curr.offset = 0;
@@ -304,7 +308,7 @@
 	  if (out->curr.offset != 0)
 	       OutNewLine(out);
 	  if (!FormatReadably)
-	       fprintf(out->f, "# %d\n", pcoord->line);
+	       gbprintf(out->gb, "# %d\n", pcoord->line);
 	  out->curr.line = pcoord->line;
 	  out->curr.offset = 0;
      }
@@ -341,7 +345,7 @@
 }
 
 PRIVATE inline void OutNewLine(OutputContext *out) {
-     fputc('\n', out->f);
+     gbputs("\n", out->gb);
      ++out->curr.line;
      out->curr.offset=0;
      out->prev_char = '\n';
@@ -349,7 +353,7 @@
 
 PRIVATE inline void OutCh(OutputContext *out, int ch)
 {
-     fputc(ch, out->f);
+     gbprintf(out->gb, "%c", ch);
      ++out->curr.offset;
      out->prev_char = ch;
 }
@@ -357,7 +361,8 @@
 PRIVATE inline void OutS(OutputContext *out, const char *s)
 {
      int len = strlen(s);
-     fputs(s, out->f);
+     int r = gbputs(s, out->gb);
+     assert(r>=0);
      out->curr.offset += len;
      out->prev_char = s[len-1];
 }
@@ -462,18 +467,18 @@
      /* Hacks to deal with the designated initializer and array initializer syntax */
      if (node->u.binop.op == DESIGNATED_INITIALIZER) {
 	  SetOutputCoord(out, &node->coord);
-	  fputs(".", out->f);
+	  gbputs(".", out->gb);
 	  OutOffset(out, 1);
      } else if (node->u.binop.op == ARRAY_LABELED_INITIALIZER) {
 	  SetOutputCoord(out, &node->coord);
-	  fputs("[", out->f);
+	  gbputs("[", out->gb);
 	  OutOffset(out, 1);
      }
 
      OutputInnerExpr(out, node->u.binop.left, my_precedence, Left);
 
      SetOutputCoord(out, &node->coord);
-     OutOffset(out, PrintOp(out->f, node->u.binop.op));
+     OutOffset(out, PrintOp(out->gb, node->u.binop.op));
 
      OutputInnerExpr(out, node->u.binop.right, my_precedence, Right);
 }
@@ -500,7 +505,7 @@
 	 case PREDEC:
 	 case PREINC:
 	      SetOutputCoord(out, &node->coord);
-	      OutOffset(out, PrintOp(out->f, node->u.unary.op));
+	      OutOffset(out, PrintOp(out->gb, node->u.unary.op));
 	      OutputInnerExpr(out, node->u.unary.expr, my_precedence, Right);
 	      break;
 
@@ -508,12 +513,12 @@
 	 case POSTINC:
 	      OutputInnerExpr(out, node->u.unary.expr, my_precedence, Left);
 	      SetOutputCoord(out, &node->coord);
-	      OutOffset(out, PrintOp(out->f, node->u.unary.op));
+	      OutOffset(out, PrintOp(out->gb, node->u.unary.op));
 	      break;
 
 	 default:
 	      SetOutputCoord(out, &node->coord);
-	      OutOffset(out, PrintOp(out->f, node->u.unary.op));
+	      OutOffset(out, PrintOp(out->gb, node->u.unary.op));
 	      OutputInnerExpr(out, node->u.unary.expr, my_precedence, Right);
 	      break;
      }
@@ -575,6 +580,110 @@
      OutCh(out, ')');
 }
 
+PRIVATE void output_constant(OutputContext *out, Node *c, Bool with_name)
+{
+     if (with_name)
+	  switch (c->u.Const.type->typ) {
+	      case Prim:
+		   output_prim_type(out, c->u.Const.type, NULL, TRUE);
+		   OutS(out, " ");
+		   OutOffset(out, 1);
+		   break;
+		   /* Used for strings */
+	      case Adcl:
+		   assert(c->u.Const.type->u.adcl.type->typ == Prim);
+		   OutS(out, "array of ");
+		   OutOffset(out, 9);
+		   output_prim_type(out, c->u.Const.type->u.adcl.type,  0, TRUE);
+		   OutS(out, " ");
+		   OutOffset(out, 1);
+		   break;
+	      default:
+		   OutS(out, "??? ");
+	  }
+     switch (c->u.Const.type->typ) {
+	 case Prim:
+	      switch (c->u.Const.type->u.prim.basic) {
+		  case Sint:
+		       OutOffset(out, gbprintf(out->gb, "%d", c->u.Const.value.i));
+		       return;
+		       /*Manish 2/3 hack to print pointer constants */
+		  case Uint:
+		       OutOffset(out, gbprintf(out->gb, "%uU", c->u.Const.value.u));
+		       return;
+		  case Slong:
+		       OutOffset(out, gbprintf(out->gb, "%ldL", c->u.Const.value.l));
+		       return;
+		  case Ulong:
+		       OutOffset(out, gbprintf(out->gb, "%luUL", c->u.Const.value.ul));
+		       return;
+		  case Float:
+		       OutOffset(out, print_float(out->gb, c->u.Const.value.f));
+		       return;
+		  case Double:
+		       OutOffset(out, print_double(out->gb, c->u.Const.value.d));
+		       return;
+		  case Char:
+		  case Schar:
+		  case Uchar:
+		       OutOffset(out, PrintChar(out->gb, c->u.Const.value.i));
+		       return;
+		  default:
+		       Fail(__FILE__, __LINE__, "");
+		       return;
+	      }
+
+	      /* Manish 2/3  Print Constant Pointers */
+	 case Ptr:
+	      OutOffset(out, gbprintf(out->gb, "%u", c->u.Const.value.u));
+	      return;
+	      /* Used for strings */
+	 case Adcl:
+	      OutOffset(out, PrintString(out->gb, c->u.Const.value.s));
+	      return;
+
+	 default:
+	     FAIL("Unrecognized constant type");
+     }
+}
+
+PRIVATE void output_prim_type (OutputContext *out, Node *type, char *lastc, Bool print_coords)
+{
+    const char *tn=TypeName(type->u.prim.basic);
+    int tn_len=strlen(tn);
+    assert(type);
+    assert(type->typ == Prim);
+    OutputTQ(out, tq_remove_sue_elaborated(type->u.prim.tq), print_coords? &type->coord : 0); /* Don't print sue_elaborated */
+    if (print_coords) SetOutputCoord(out, &type->coord);
+    OutS(out, tn);
+    if (lastc)
+	*lastc = tn[tn_len-1];
+    return;
+}
+
+GLOBAL void output_prim_type_to_GBUF(GBUF *gb, Node *type, char *lastc) {
+     OutputContext out;
+     out.prev_char=' ';
+     out.curr=DontPrintCoord;
+     out.block = 0;
+     out.block_indents[0]=0;
+     out.gb = gb;
+     return output_prim_type(&out, type, lastc, FALSE);
+}
+
+GLOBAL void output_constant_to_GBUF(GBUF * gb, Node *node, Bool with_name) {
+     /* Make a dummy outputcontext.  This function is only called through the print_ast methods (and possibly for error messages)
+      * so the exact coordinate is not very important. */
+     OutputContext out;
+     out.prev_char=' ';
+     out.curr=UnknownCoord;
+     out.block = 0;
+     out.block_indents[0]=0;
+     out.gb = gb;
+     output_constant(&out, node, with_name);
+}
+
+
 PRIVATE void OutputInnerExpr(OutputContext *out, Node *node,
 			     int enclosing_precedence, Context context)
 {
@@ -636,7 +745,7 @@
 	      if (node->u.Const.text)
 		   OutS(out, node->u.Const.text);
 	      else
-		   OutOffset(out, PrintConstant(out->f, node, FALSE));
+		   output_constant(out, node, FALSE);
 	      break;
 	 case Binop:
 	      OutputBinop(out, node, my_precedence);
@@ -706,7 +815,7 @@
 	      break;
 	 default:
 	      fprintf(stderr, "Internal error: unexpected node (%s:%d)\n", __FILE__, __LINE__);
-	      PrintNode(stderr, node, 2);
+	      fPrintNode(stderr, node, 2);
 	      UNREACHABLE;
      }
 
@@ -719,18 +828,131 @@
      OutputInnerExpr(out, node, 0, Left);
 }
 
+GLOBAL int add_string_to_OutputContext (const char *string, void *output_context_v) {
+     OutputContext *out = output_context_v;
+     OutS(out, string);
+     return 1;
+}
+
+GLOBAL void TQtoGBUF (GBUF *gb, TypeQual tq) {
+     OutputContext out;
+     out.prev_char=' ';
+     out.curr=DontPrintCoord;
+     out.block = 0;
+     out.block_indents[0]=0;
+     out.gb = gb;
+     OutputTQ (&out, tq, 0);
+}
+
 PRIVATE void OutputTQ (OutputContext *out, TypeQual tq, Coord *coord)
 /* Print the type qualifier at coord.  If the type qualifier is empty, then nothing is printed. */
 {
-     char tmp[256];
-     int len;
-     TQtoText(tmp, tq);
-     len = strlen(tmp);
-     if (len>0) {
-	  if (coord)
-	       SetOutputCoord(out, coord);
-	  OutS(out, tmp);
+     if (tq_has_anything(tq) && coord) {
+	  SetOutputCoord(out, coord);
+     }
+#define ASF(_string) OutS(out, _string)
+     if (tq_has_extension(tq)) {
+	 ASF("__extension__ ");
+     }
+
+     /* storage class */
+     if (tq_has_typedef(tq))
+	  ASF("typedef ");
+     else if (tq_has_extern(tq))
+	  ASF("extern ");
+     else if (tq_has_static(tq))
+	  ASF("static ");
+     else if (tq_has_auto(tq))
+	  ASF("auto ");
+     else if (tq_has_register(tq))
+	  ASF("register ");
+     else {
+	  ; /* no explicit storage class */
+     }
+
+     /* location */
+     if (tq_has_top_decl(tq)) 
+	  ASF("top_decl ");
+     else if (tq_has_block_decl(tq))
+	  ASF("block_decl ");
+     else if (tq_has_formal_decl(tq))
+	  ASF("formal_decl ");
+     else if (tq_has_su_decl(tq))
+	  ASF("su_decl ");
+     else if (tq_has_enum_decl(tq))
+	  ASF("enum_decl ");
+     else {
+	  ; /* no explicit location */
+     }
+
+     if (tq_has_redundant_external_decl(tq))
+	 ASF("redundant_extern ");
+
+     if (tq_has_shared(tq))
+	 ASF("shared ");
+     if (tq_has_private(tq))
+	 ASF("private ");
+     
+     if (tq_has_inline(tq)) {
+          #ifdef inline
+/* This hacking is the standard CPP idiom for stringifying the result of a macro expansion.
+ * In this case, the macro inline might be defined in ../config.h as
+ *   #define inline __inline
+ * and we want to get the string "__inline"
+ * Suppose we did
+ *   STR(inline)
+ * that would expand to
+ *   #inline
+ * which would expand to
+ *   "inline"
+ * which is not what we want.  If we do
+ *  XSTR(inline)
+ * that expands to
+ *  STR(inline)
+ * and then the args are expanded to give
+ *  STR(__inline)
+ * and then the STR macro is expanded to give
+ *  #__inline
+ * finally yielding
+ *  "__inline"
+ * The whole point of this hack is to produce a string for "inline" that will work with the
+ * C compiler we are using,as determined by ../configure and stored in ../config.h
+ */
+#define STR(S) #S
+#define XSTR(S) STR(S)
+   	    ASF(XSTR(inline) " "); /* Use the system-specific inline from config.h  */
+          #else
+            ASF("inline ");
+          #endif
+     }
+     if (tq_has_const(tq))
+	  ASF("const ");
+     if (tq_has_volatile(tq))
+	  ASF("volatile ");
+     if (tq_has_restrict(tq))
+	  ASF("__restrict ");
+     if (tq_has_complex(tq))
+	  ASF("__complex__ ");
+     if (tq_has_nooutput(tq)) {
+	  ASF("__nooutput__ ");
+     }
+     if (tq_has_cilkonly(tq)) {
+	  ASF("__cilkonly__ ");
+     }
+     if (tq_has_cilksafe(tq)) {
+	  ASF("__cilksafe__ ");
+     }
+     if (tq_has_sue_elaborated(tq))
+	  ASF("sue_elaborated ");
+     if (tq_has_procedure(tq))
+	  ASF("cilk ");
+     if (tq_has_inlet(tq))
+	  ASF("inlet ");
+
+     if (tq.attributes) {
+	  OutputAttribs(out, tq.attributes);
      }
+
 }
 
 /*
@@ -752,9 +974,8 @@
 	       */
 	 case Prim:
 	      if (context == Left) {
-		   SetOutputCoord(out, &node->coord);
-		   OutputTQ(out, sc, 0);
-		   OutOffset(out, PrintPrimType(out->f, node, &out->prev_char));
+		   OutputTQ(out, sc, &node->coord);
+		   output_prim_type(out, node, &out->prev_char, TRUE);
 	      }
 	      /* no action in Right context */
 	      break;
@@ -775,8 +996,8 @@
 	      if (context == Left) {
 		   SetOutputCoord(out, &node->coord);
 		   OutputTQ(out, sc, 0);
-		   OutputTQ(out, node->u.sdcl.tq & (unsigned int) ~T_SUE_ELABORATED, 0);
-		   OutputSUE(out, node->u.sdcl.type, SUE_ELABORATED(node->u.sdcl.tq));
+		   OutputTQ(out, (TypeQual){tq_remove_sue_elaborated(node->u.sdcl.tq).tq, 0}, 0); /* Don't print the attributes here.  or sue_elaborated at all */
+		   OutputSUE(out, node->u.sdcl.type, tq_has_sue_elaborated(node->u.sdcl.tq), node->u.sdcl.tq.attributes);
 	      }
 	      /* no action in Right context */
 	      break;
@@ -796,8 +1017,8 @@
 		   SetOutputCoord(out, &node->coord);
 		   OutCh(out, '*');
 		   /* don't output "cilk" or "inlet" as keyword */
-		   NodeRemoveTq(node, T_PROCEDURE);
-		   NodeRemoveTq(node, T_INLET);
+		   NodeUpdateTq(node, tq_remove_procedure);
+		   NodeUpdateTq(node, tq_remove_inlet);
 		   OutputTQ(out, node->u.ptr.tq, 0);
 	      } else {
 		   if (IS_ARRAY_OR_FUNC(node->u.ptr.type))
@@ -823,8 +1044,8 @@
 	 case Fdcl:
 	      if (context == Left) {
 		   /* don't output "cilk" or "inlet" as keyword */
-		   NodeRemoveTq(node, T_PROCEDURE);
-		   NodeRemoveTq(node, T_INLET);
+		   NodeUpdateTq(node, tq_remove_procedure);
+		   NodeUpdateTq(node, tq_remove_inlet);
 		   OutputTQ(out, node->u.fdcl.tq, &node->coord);
 		   OutputPartialType(out, context, node->u.fdcl.returns, sc);
 	      } else {
@@ -839,12 +1060,12 @@
 
 	 default:
 	      fprintf(stderr, "Internal error: unexpected node (%s:%d)\n", __FILE__, __LINE__);
-	      PrintNode(stderr, node, 2);
+	      fPrintNode(stderr, node, 2);
 	      UNREACHABLE;
      }
 }
 
-PRIVATE void OutputSUE(OutputContext *out, SUEtype *sue, Bool elaboratedp)
+PRIVATE void OutputSUE(OutputContext *out, SUEtype *sue, Bool elaboratedp, List *attributes)
 {
 
      assert(sue != NULL);
@@ -863,6 +1084,9 @@
 	      UNREACHABLE;
      }
 
+     if (attributes) OutputAttribs(out, attributes);
+
+
      if (sue->name) {
 	  OutCh(out, ' ');
 	  OutS(out, sue->name);
@@ -913,17 +1137,24 @@
      assert(node->typ == Decl);
 
      /* do not output __nooutput__ declarations */
-     if (node->u.decl.tq & T_NOOUTPUT)
+     if (tq_has_nooutput(node->u.decl.tq))
 	  return 0;
 
-     if (node->u.decl.tq & T_EXTENSION) {
-	  SetOutputCoord(out, &node->coord);
+     SetOutputCoord(out, &node->coord);
+
+     if (tq_has_extension(node->u.decl.tq)) {
 	  OutS(out, "__extension__");
      }
 
      if (k != EnumConstDecl) {
-	  int sc = NodeStorageClass(node);
-	  OutputPartialType(out, Left, node->u.decl.type, sc);
+	  TypeQual sc = NodeStorageClass(node);
+	  List *attribs = NodeDeclTq(node).attributes;
+	  OutputTQ(out, sc, &node->coord);
+	  if (attribs) OutputAttribs(out, attribs);
+	  OutputPartialType(out, Left, node->u.decl.type, EMPTY_TQ);
+
+	  if (node->u.decl.attribs)
+	       OutputAttribs(out, node->u.decl.attribs);
 
 	  if (node->u.decl.name) {
 	       SetOutputCoord(out, &node->coord);
@@ -931,12 +1162,14 @@
 		    OutCh(out, ' ');
 	       OutS(out, node->u.decl.name);
 	  }
-	  OutputPartialType(out, Right, node->u.decl.type, sc);
+
+	  OutputPartialType(out, Right, node->u.decl.type, EMPTY_TQ);
      } else {
 	  SetOutputCoord(out, &node->coord);
 	  OutS(out, node->u.decl.name);
+	  if (node->u.decl.attribs)
+	       OutputAttribs(out, node->u.decl.attribs);
      }
-
      switch (k) {
 	 case SUFieldDecl:
 	      if (node->u.decl.bitsize != NULL) {
@@ -945,8 +1178,6 @@
 	      }
 	      if (node->u.decl.asmdecl)
 		   OutputAsmDecl(out, node->u.decl.asmdecl);
-	      if (node->u.decl.attribs)
-		   OutputAttribs(out, node->u.decl.attribs);
 	      break;
 
 	 case TopDecl:
@@ -954,8 +1185,6 @@
 	 case EnumConstDecl:
 	      if (node->u.decl.asmdecl)
 		   OutputAsmDecl(out, node->u.decl.asmdecl);
-	      if (node->u.decl.attribs)
-		   OutputAttribs(out, node->u.decl.attribs);
 	      if (IsSourceExpression(node->u.decl.init)) {
 		   OutCh(out, '=');
 		   OutputExpr(out, node->u.decl.init);
@@ -965,8 +1194,6 @@
 	 case FormalDecl:
 	      if (node->u.decl.asmdecl)
 		   OutputAsmDecl(out, node->u.decl.asmdecl);
-	      if (node->u.decl.attribs)
-		   OutputAttribs(out, node->u.decl.attribs);
 	      break;
      }
      return 1;
@@ -974,7 +1201,8 @@
 
 PRIVATE void OutputAttribs(OutputContext *out, List *attribs)
 {
-     OutS(out, " __attribute__((");
+     if (out->prev_char!=' ') OutCh(out, ' ');
+     OutS(out, "__attribute__((");
      while (attribs != NULL) {
 	  Node *attrib = FirstItem(attribs);
 
@@ -1151,7 +1379,7 @@
 	 case Asm:
 	      SetOutputCoordStmt(out, &node->coord);
 	      OutS(out, "__asm__");
-	      if (node->u.Asm.tq) {
+	      if (tq_has_anything(node->u.Asm.tq)) {
 		   OutCh(out, ' ');
 		   OutputTQ(out, node->u.Asm.tq, 0);
 	      }
@@ -1188,13 +1416,13 @@
 	      break;
 	 default:
 	      fprintf(stderr, "Internal error: unexpected node (%s:%d)\n", __FILE__, __LINE__);
-	      PrintNode(stderr, node, 2);
+	      fPrintNode(stderr, node, 2);
 	      UNREACHABLE;
      }
 
      if (PrintLiveVars && node->analysis.livevars) {
 	  OutS(out, " /* ");
-	  OutOffset(out, PrintAnalysis(out->f, node));
+	  OutOffset(out, PrintAnalysis(out->gb, node));
 	  OutS(out, " */");
      }
 }
@@ -1250,31 +1478,35 @@
 		  TypeQual tq = node->u.proc.decl->u.decl.tq;;
 		  if (Transform) {
 
-		      fputs("\n#undef CILK_WHERE_AM_I", out->f);
-		      fputs("\n#define CILK_WHERE_AM_I ", out->f);
+		      gbputs("\n#undef CILK_WHERE_AM_I", out->gb);
+		      gbputs("\n#define CILK_WHERE_AM_I ", out->gb);
 		      
-		      if (tq & T_FAST_PROCEDURE)
-			  fputs("IN_FAST_PROCEDURE\n", out->f);
-		      else if (tq & T_SLOW_PROCEDURE)
-			  fputs("IN_SLOW_PROCEDURE\n", out->f);
-		      else if (tq & T_FAST_INLET)
-			  fputs("IN_FAST_INLET\n", out->f);
-		      else if (tq & T_SLOW_INLET)
-			  fputs("IN_SLOW_INLET\n", out->f);
-		      else if (tq & T_STANDALONE_INLET)
-			  fputs("IN_STANDALONE_INLET\n", out->f);
-		      else if (tq & T_C_CODE)
-			  fputs("IN_C_CODE\n", out->f);
+		      if (tq_has_fast_procedure(tq))
+			  gbputs("IN_FAST_PROCEDURE\n", out->gb);
+		      else if (tq_has_slow_procedure(tq))
+			  gbputs("IN_SLOW_PROCEDURE\n", out->gb);
+		      else if (tq_has_fast_inlet(tq))
+			  gbputs("IN_FAST_INLET\n", out->gb);
+		      else if (tq_has_slow_inlet(tq))
+			  gbputs("IN_SLOW_INLET\n", out->gb);
+		      else if (tq_has_standalone_inlet(tq))
+			  gbputs("IN_STANDALONE_INLET\n", out->gb);
+		      else if (tq_has_c_code(tq))
+			  gbputs("IN_C_CODE\n", out->gb);
 		      else {
 			  fprintf(stderr, "unknown type of procedure\n");
-			  PrintTQ(stderr, tq);
-			  PrintNode(stderr, node, 2);
+			  {
+			       GBUF *gb=make_file_gbuf(stderr);
+			       PrintTQ(gb, tq, 0, 0);
+			       PrintNode(gb, node, 2);
+			       free_gbuf(gb);
+			  }
 			  UNREACHABLE;
 		      }
 		      out->curr.line += 3;
 		      out->curr.offset = 0;
 		  } else {
-		      assert(0 == (tq & T_CILK_WHERE_AM_I_DECL_QUALS));
+		       assert(!tq_has_cilk_where_am_i_decl_quals(tq));
 		  }
 	      }
       
@@ -1315,7 +1547,7 @@
 
 	  default:
 	      fprintf(stderr, "Internal error: unexpected node (%s:%d)\n", __FILE__, __LINE__);
-	      PrintNode(stderr, node, 2);
+	      fPrintNode(stderr, node, 2);
 	      UNREACHABLE;
 	  }
      }
diff -Nur 5.4.2.2/cilk2c/print-ast.c current.Bug188/cilk2c/print-ast.c
--- 5.4.2.2/cilk2c/print-ast.c	2004-10-23 03:26:45.000000000 +0000
+++ current.Bug188/cilk2c/print-ast.c	2005-10-22 02:52:37.000000000 +0000
@@ -30,7 +30,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/print-ast.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/print-ast.c $ $LastChangedBy: bradley $ $Rev: 2484 $ $Date$");
 
 #include <ctype.h>
 
@@ -38,29 +38,29 @@
 
 GLOBAL void DPN(Node *n)
 {
-     PrintNode(stdout, n, 0);
+     fPrintNode(stdout, n, 0);
      putchar('\n');
      fflush(stdout);
 }
 
 GLOBAL void DPL(List *list)
 {
-     PrintList(stdout, list, 0);
+     fPrintList(stdout, list, 0);
      putchar('\n');
      fflush(stdout);
 }
 
-GLOBAL void PrintCoord (FILE *out, Coord *c) {
+GLOBAL void PrintCoord (GBUF *out, Coord *c) {
 #if 0
     static int prevfilenum=-1;
-    fprintf(out, "<");
+    gbprintf(out, "<");
     if (prevfilenum!=c->file) {
-	fprintf(out, "%s:", FileNames[c->file]);
+	gbprintf(out, "%s:", FileNames[c->file]);
 	prevfilenum=c->file;
     }
 #endif
     if (PrintASTcoords)
-	fprintf(out, " <%d.%d>", c->line, c->offset);
+	gbprintf(out, " <%d.%d>", c->line, c->offset);
 }
 
 
@@ -70,32 +70,32 @@
 /*                                                                       */
 /*************************************************************************/
 
-PRIVATE inline void PrintConst(FILE *out, Node *node, UNUSED(ConstNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintConst(GBUF *gb, Node *node, UNUSED(ConstNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Const: ");
-     PrintConstant(out, node, TRUE);
+    gbprintf(gb, "Const: ");
+    output_constant_to_GBUF(gb, node, TRUE);
 }
 
-PRIVATE inline void PrintId(FILE *out, Node *node, idNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintId(GBUF *out, Node *node, idNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Id: %s", u->text);
+     gbprintf(out, "Id: %s", u->text);
      PrintCoord(out, &node->coord);
      if (u->value) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Value: ", out);
+	  gbputs("Value: ", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->value, offset + 4);
      }
      PrintCRSpaces(out, offset + 2);
-     fputs("decl: ", out);
+     gbputs("decl: ", out);
      PrintNode(out, u->decl, offset+4);
      /* PrintCRSpaces(out, offset + 2);*/
      /* PrintNode(out, u->decl, offset + 2); KHR */
 }
 
-PRIVATE inline void PrintBinop(FILE *out, Node *node, binopNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintBinop(GBUF *out, Node *node, binopNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Binop: ");
+     gbprintf(out, "Binop: ");
      PrintOp(out, u->op);
      PrintCoord(out, &node->coord);
      if (u->type) {
@@ -104,7 +104,7 @@
      }
      if (u->value) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Value: ", out);
+	  gbputs("Value: ", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->value, offset + 4);
      }
@@ -114,9 +114,9 @@
      PrintNode(out, u->right, offset + 2);
 }
 
-PRIVATE inline void PrintUnary(FILE *out, Node *node, unaryNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintUnary(GBUF *out, Node *node, unaryNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Unary: ");
+     gbprintf(out, "Unary: ");
      PrintOp(out, u->op);
      PrintCoord(out, &node->coord);
      if (u->type) {
@@ -125,7 +125,7 @@
      }
      if (u->value) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Value: ", out);
+	  gbputs("Value: ", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->value, offset + 4);
      }
@@ -133,13 +133,13 @@
      PrintNode(out, u->expr, offset + 2);
 }
 
-PRIVATE inline void PrintCast(FILE *out, UNUSED(Node *node), castNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintCast(GBUF *out, UNUSED(Node *node), castNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("Cast: ", out);
+     gbputs("Cast: ", out);
      PrintCoord(out, &node->coord);
      if (u->value) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Value: ", out);
+	  gbputs("Value: ", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->value, offset + 4);
      }
@@ -149,29 +149,29 @@
      PrintNode(out, u->expr, offset + 2);
 }
 
-PRIVATE inline void PrintComma(FILE *out, Node *node, commaNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintComma(GBUF *out, Node *node, commaNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Comma: List: exprs <%d.%d>", node->coord.line, node->coord.offset);
-     if (node->parenthesized) fprintf(out, " parenthesized");
+     gbprintf(out, "Comma: List: exprs <%d.%d>", node->coord.line, node->coord.offset);
+     if (node->parenthesized) gbprintf(out, " parenthesized");
      PrintCRSpaces(out, offset + 2);
      PrintList(out, u->exprs, offset + 2);
 }
 
-PRIVATE inline void PrintConstructor(FILE *out, UNUSED(Node *node), constructorNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintConstructor(GBUF *out, UNUSED(Node *node), constructorNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Constructor: List: exprs");
+     gbprintf(out, "Constructor: List: exprs");
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->type, offset + 2);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->initializerlist, offset + 2);
 }
 
-PRIVATE inline void PrintTernary(FILE *out, UNUSED(Node *node), ternaryNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintTernary(GBUF *out, UNUSED(Node *node), ternaryNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("Ternary: ", out);
+     gbputs("Ternary: ", out);
      if (u->value) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Value: ", out);
+	  gbputs("Value: ", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->value, offset + 4);
      }
@@ -183,9 +183,9 @@
      PrintNode(out, u->false, offset + 2);
 }
 
-PRIVATE inline void PrintArray(FILE *out, UNUSED(Node *node), arrayNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintArray(GBUF *out, UNUSED(Node *node), arrayNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("Array: ", out);
+     gbputs("Array: ", out);
      if (u->type) {
 	  PrintCRSpaces(out, offset + 2);
 	  PrintNode(out, u->type, offset + 2);
@@ -193,41 +193,41 @@
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->name, offset + 2);
      PrintCRSpaces(out, offset + 2);
-     fputs("List: dims", out);
+     gbputs("List: dims", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->dims, offset + 4);
 }
 
-PRIVATE inline void PrintCall(FILE *out, UNUSED(Node *node), callNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintCall(GBUF *out, UNUSED(Node *node), callNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("Call: ", out);
+     gbputs("Call: ", out);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->name, offset + 2);
      PrintCRSpaces(out, offset + 2);
-     fputs("List: args", out);
+     gbputs("List: args", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->args, offset + 4);
 }
 
-PRIVATE inline void PrintInitializer(FILE *out, UNUSED(Node *node), initializerNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintInitializer(GBUF *out, UNUSED(Node *node), initializerNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Initializer: List: exprs");
+     gbprintf(out, "Initializer: List: exprs");
      PrintCRSpaces(out, offset + 2);
      PrintList(out, u->exprs, offset + 2);
 }
 
-PRIVATE inline void PrintImplicitCast(FILE *out, UNUSED(Node *node), implicitcastNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintImplicitCast(GBUF *out, UNUSED(Node *node), implicitcastNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("ImplicitCast: ", out);
+     gbputs("ImplicitCast: ", out);
      if (u->type) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Type:", out);
+	  gbputs("Type:", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->type, offset + 2);
      }
      if (u->value) {
 	  PrintCRSpaces(out, offset + 2);
-	  fputs("Value: ", out);
+	  gbputs("Value: ", out);
 	  PrintCRSpaces(out, offset + 4);
 	  PrintNode(out, u->value, offset + 4);
      }
@@ -241,20 +241,20 @@
 /*                                                                       */
 /*************************************************************************/
 
-PRIVATE inline void PrintLabel(FILE *out, Node *node, labelNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintLabel(GBUF *out, Node *node, labelNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Label: %s (%d)", u->name, node->print_uid);
+     gbprintf(out, "Label: %s (%d)", u->name, node->print_uid);
 #if 0
-     fprintf(out, "Label: %s", u->name);
+     gbprintf(out, "Label: %s", u->name);
 #endif
 }
 
-PRIVATE inline void PrintSwitch(FILE *out, Node *node, SwitchNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintSwitch(GBUF *out, Node *node, SwitchNode *u, int offset, UNUSED(Bool norecurse))
 {
      ListMarker marker;
      Node *cse;
 
-     fprintf(out, "Switch: (%d)", node->print_uid);
+     gbprintf(out, "Switch: (%d)", node->print_uid);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->expr, offset + 2);
      PrintCRSpaces(out, offset + 2);
@@ -262,41 +262,41 @@
      PrintCRSpaces(out, offset + 2);
 
      IterateList(&marker, u->cases);
-     fprintf(out, "Cases:");
+     gbprintf(out, "Cases:");
      while (NextOnList(&marker, (GenericREF) & cse)) {
-	  fprintf(out, " %d", cse->coord.line);
+	  gbprintf(out, " %d", cse->coord.line);
      }
 }
 
-PRIVATE inline void PrintCase(FILE *out, UNUSED(Node *node), CaseNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintCase(GBUF *out, UNUSED(Node *node), CaseNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Case: (container = %d)", u->container->print_uid);
+     gbprintf(out, "Case: (container = %d)", u->container->print_uid);
 #if 0
-     fprintf(out, "Case: ");
+     gbprintf(out, "Case: ");
 #endif
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->expr, offset + 2);
      PrintCRSpaces(out, offset + 2);
 }
 
-PRIVATE inline void PrintDefault(FILE *out, UNUSED(Node *node), DefaultNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintDefault(GBUF *out, UNUSED(Node *node), DefaultNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Default: (container = %d)", u->container->print_uid);
+     gbprintf(out, "Default: (container = %d)", u->container->print_uid);
      PrintCRSpaces(out, offset + 2);
 }
 
-PRIVATE inline void PrintIf(FILE *out, UNUSED(Node *node), IfNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintIf(GBUF *out, UNUSED(Node *node), IfNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("If: ", out);
+     gbputs("If: ", out);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->expr, offset + 2);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->stmt, offset + 2);
 }
 
-PRIVATE inline void PrintIfElse(FILE *out, UNUSED(Node *node), IfElseNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintIfElse(GBUF *out, UNUSED(Node *node), IfElseNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("IfElse: ", out);
+     gbputs("IfElse: ", out);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->expr, offset + 2);
      PrintCRSpaces(out, offset + 2);
@@ -305,27 +305,27 @@
      PrintNode(out, u->false, offset + 2);
 }
 
-PRIVATE inline void PrintWhile(FILE *out, Node *node, WhileNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintWhile(GBUF *out, Node *node, WhileNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "While: (%d) ", node->print_uid);
+     gbprintf(out, "While: (%d) ", node->print_uid);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->expr, offset + 2);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->stmt, offset + 2);
 }
 
-PRIVATE inline void PrintDo(FILE *out, Node *node, DoNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintDo(GBUF *out, Node *node, DoNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Do: (%d) ", node->print_uid);
+     gbprintf(out, "Do: (%d) ", node->print_uid);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->stmt, offset + 2);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->expr, offset + 2);
 }
 
-PRIVATE inline void PrintFor(FILE *out, Node *node, ForNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintFor(GBUF *out, Node *node, ForNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "For: (%d) ", node->print_uid);
+     gbprintf(out, "For: (%d) ", node->print_uid);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->init, offset + 2);
      PrintCRSpaces(out, offset + 2);
@@ -336,31 +336,31 @@
      PrintNode(out, u->stmt, offset + 2);
 }
 
-PRIVATE inline void PrintGoto(FILE *out, UNUSED(Node *node), GotoNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintGoto(GBUF *out, UNUSED(Node *node), GotoNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Goto: %s",
+     gbprintf(out, "Goto: %s",
 	     (u->label ? u->label->u.label.name : "nil"));
 }
 
-PRIVATE inline void PrintContinue(FILE *out, UNUSED(Node *node), ContinueNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintContinue(GBUF *out, UNUSED(Node *node), ContinueNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Continue: (container = %d)", u->container->print_uid);
+     gbprintf(out, "Continue: (container = %d)", u->container->print_uid);
 #if 0
-     fprintf(out, "Continue: ");
+     gbprintf(out, "Continue: ");
 #endif
 }
 
-PRIVATE inline void PrintBreak(FILE *out, UNUSED(Node *node), BreakNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintBreak(GBUF *out, UNUSED(Node *node), BreakNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Break: (container = %d)", u->container->print_uid);
+     gbprintf(out, "Break: (container = %d)", u->container->print_uid);
 #if 0
-     fprintf(out, "Break: ");
+     gbprintf(out, "Break: ");
 #endif
 }
 
-PRIVATE inline void PrintReturn(FILE *out, UNUSED(Node *node), ReturnNode *u, int offset, Bool UNUSED(norecurse))
+PRIVATE inline void PrintReturn(GBUF *out, UNUSED(Node *node), ReturnNode *u, int offset, Bool UNUSED(norecurse))
 {
-     fputs("Return: ", out);
+     gbputs("Return: ", out);
 #if 0
      if (u->expr) {
 	  PrintCRSpaces(out, offset + 2);
@@ -371,28 +371,28 @@
      PrintNode(out, u->expr, offset + 2);
 }
 
-PRIVATE inline void PrintBlock(FILE *out, UNUSED(Node *node), BlockNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintBlock(GBUF *out, UNUSED(Node *node), BlockNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("Block:", out);
-     if (node->parenthesized) fprintf(out, " parenthesized");
+     gbputs("Block:", out);
+     if (node->parenthesized) gbprintf(out, " parenthesized");
      PrintCRSpaces(out, offset + 2);
      if (u->type) {
-	 fprintf(out, "Type: (%d)", u->type->print_uid);
+	 gbprintf(out, "Type: (%d)", u->type->print_uid);
      } else {
-	 fprintf(out, "Type: nil");
+	 gbprintf(out, "Type: nil");
      }
 #if 0
-     fputs("Type:", out);
+     gbputs("Type:", out);
 #endif
      PrintCRSpaces(out, offset + 4);
      PrintNode(out, u->type, offset + 4);
      PrintCRSpaces(out, offset + 2);
-     fputs("List: decl", out);
+     gbputs("List: decl", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->decl, offset + 4);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: stmts", out);
+     gbputs("List: stmts", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->stmts, offset + 4);
 }
@@ -404,22 +404,22 @@
 /*                                                                       */
 /*************************************************************************/
 
-PRIVATE inline void PrintPrim(FILE *out, Node *node, UNUSED(primNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintPrim(GBUF *out, Node *node, UNUSED(primNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Prim: ");
-     PrintPrimType(out, node, 0);
+     gbprintf(out, "Prim: ");
+     output_prim_type_to_GBUF(out, node, 0);
      PrintCoord(out, &node->coord);
 }
 
-PRIVATE inline void PrintTdef(FILE *out, Node *node, tdefNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintTdef(GBUF *out, Node *node, tdefNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
      /* temp fix for core dump when printing ast  -Angelina */
      if( u->type == NULL ) 
-          fprintf(out, "Tdef: %s (%d) (type=NULL)  ", u->name, node->print_uid);
+          gbprintf(out, "Tdef: %s (%d) (type=NULL)  ", u->name, node->print_uid);
      else 
-          fprintf(out, "Tdef: %s (%d) (type=%d)  ", u->name, node->print_uid, u->type->print_uid); 
+          gbprintf(out, "Tdef: %s (%d) (type=%d)  ", u->name, node->print_uid, u->type->print_uid); 
      PrintCoord(out, &node->coord);
-     PrintTQ(out, u->tq);
+     PrintTQ(out, u->tq, offset, norecurse);
 #if 0
      if (!norecurse) {
 	  PrintCRSpaces(out, offset + 2);
@@ -428,79 +428,79 @@
 #endif
 }
 
-PRIVATE inline void PrintPtr(FILE *out, UNUSED(Node *node), ptrNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintPtr(GBUF *out, UNUSED(Node *node), ptrNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Ptr: ");
-     PrintTQ(out, u->tq);
+     gbprintf(out, "Ptr: ");
+     PrintTQ(out, u->tq, offset, norecurse);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->type, offset + 2);
 }
 
-PRIVATE inline void PrintAdcl(FILE *out, Node *node, adclNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintAdcl(GBUF *out, Node *node, adclNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Adcl: (%d)", node->print_uid);
-     PrintTQ(out, u->tq);
+     gbprintf(out, "Adcl: (%d)", node->print_uid);
+     PrintTQ(out, u->tq, offset, norecurse);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->type, offset + 2);
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->dimp->dim, offset + 2);
      if (u->dimp->size > 0) {
 	  PrintCRSpaces(out, offset + 2);
-	  fprintf(out, "%d", u->dimp->size);
+	  gbprintf(out, "%d", u->dimp->size);
      }
 }
 
-PRIVATE inline void PrintFdcl(FILE *out, Node *node, fdclNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintFdcl(GBUF *out, Node *node, fdclNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Fdcl:");
+     gbprintf(out, "Fdcl:");
      PrintCoord(out, &node->coord);
-     fprintf(out, " ");
-     PrintTQ(out, u->tq);
+     gbprintf(out, " ");
+     PrintTQ(out, u->tq, offset, norecurse);
      PrintCRSpaces(out, offset + 2);
-     fputs("List: Args: ", out);
+     gbputs("List: Args: ", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->args, offset + 4);
      PrintCRSpaces(out, offset + 2);
-     fputs("Returns: ", out);
+     gbputs("Returns: ", out);
      PrintCRSpaces(out, offset + 4);
      PrintNode(out, u->returns, offset + 4);
 }
 
-PRIVATE inline void PrintSdcl(FILE *out, Node *node, sdclNode *u, int offset, Bool norecurse)
+PRIVATE inline void PrintSdcl(GBUF *out, Node *node, sdclNode *u, int offset, Bool norecurse)
 {
-     fprintf(out, "Sdcl: (%d) ", node->print_uid);
+     gbprintf(out, "Sdcl: (%d) ", node->print_uid);
 
      if (norecurse)
-	  fprintf(out, "%s\n", u->type->name);
+	  gbprintf(out, "%s\n", u->type->name);
      else {
 	  PrintCRSpaces(out, offset + 2);
-	  PrintTQ(out, u->tq);
+	  PrintTQ(out, u->tq, offset+2, norecurse);
 	  PrintSUE(out, u->type, offset + 4, TRUE);
      }
 }
 
-PRIVATE inline void PrintUdcl(FILE *out, Node *node, udclNode *u, int offset, Bool norecurse)
+PRIVATE inline void PrintUdcl(GBUF *out, Node *node, udclNode *u, int offset, Bool norecurse)
 {
-     fprintf(out, "Udcl: (%d) ", node->print_uid);
+     gbprintf(out, "Udcl: (%d) ", node->print_uid);
 
      if (norecurse)
-	  fprintf(out, "%s\n", u->type->name);
+	  gbprintf(out, "%s\n", u->type->name);
      else {
 	  PrintCRSpaces(out, offset + 2);
-	  PrintTQ(out, u->tq);
+	  PrintTQ(out, u->tq, offset+2, norecurse);
 	  PrintSUE(out, u->type, offset + 4, TRUE);
      }
 }
 
-PRIVATE inline void PrintEdcl(FILE *out, Node *node, edclNode *u, int offset, Bool norecurse)
+PRIVATE inline void PrintEdcl(GBUF *out, Node *node, edclNode *u, int offset, Bool norecurse)
 {
-     fprintf(out, "Edcl: (%d) ", node->print_uid);
+     gbprintf(out, "Edcl: (%d) ", node->print_uid);
 
      if (norecurse)
-	  fprintf(out, "%s\n", u->type->name);
+	  gbprintf(out, "%s\n", u->type->name);
      else {
 	  PrintCRSpaces(out, offset + 2);
-	  PrintTQ(out, u->tq);
+	  PrintTQ(out, u->tq, offset+2, norecurse);
 	  PrintSUE(out, u->type, offset + 4, TRUE);
      }
 }
@@ -511,15 +511,15 @@
 /*                                                                       */
 /*************************************************************************/
 
-PRIVATE inline void PrintDecl(FILE *out, Node *node, declNode *u, int offset, Bool norecurse)
+PRIVATE inline void PrintDecl(GBUF *out, Node *node, declNode *u, int offset, Bool norecurse)
 {
-     fprintf(out, "Decl: %s (%d)", u->name ? u->name : "", node->print_uid);
+     gbprintf(out, "Decl: %s (%d)", u->name ? u->name : "", node->print_uid);
      PrintCoord(out, &node->coord);
-     fprintf(out, " ");
-     PrintTQ(out, u->tq);
+     gbprintf(out, " ");
+     PrintTQ(out, u->tq, offset+2, norecurse);
 
      if (norecurse)
-	  fprintf(out, "\n");
+	  gbprintf(out, "\n");
      else {
 	  PrintCRSpaces(out, offset + 2);
 	  PrintNode(out, u->type, offset + 2);
@@ -534,28 +534,28 @@
      }
 }
 
-PRIVATE inline void PrintAttrib(FILE *out, UNUSED(Node *node), attribNode *u,
+PRIVATE inline void PrintAttrib(GBUF *out, UNUSED(Node *node), attribNode *u,
 				int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Attrib: %s", u->name);
+     gbprintf(out, "Attrib: %s", u->name);
 
      PrintCRSpaces(out, offset + 2);
      PrintList(out, u->arglist, offset + 2);
 }
 
-PRIVATE inline void PrintProc(FILE *out, UNUSED(Node *node), procNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintProc(GBUF *out, UNUSED(Node *node), procNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fputs("Proc:\n  ", out);
+     gbputs("Proc:\n  ", out);
      PrintNode(out, u->decl, 2);
-     fputs("\n  ", out);
+     gbputs("\n  ", out);
      PrintNode(out, u->body, 2);
 }
 
-PRIVATE inline void PrintText(FILE *out, UNUSED(Node *node), textNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintText(GBUF *out, UNUSED(Node *node), textNode *u, UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fputs("Text: ", out);
+     gbputs("Text: ", out);
      if (u->start_new_line)
-	  fputs("(new line) ", out);
+	  gbputs("(new line) ", out);
      PrintString(out, u->text);
 }
 
@@ -565,40 +565,40 @@
 /*                                                                       */
 /*************************************************************************/
 
-PRIVATE inline void PrintAsm(FILE *out, UNUSED(Node *node), asmNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintAsm(GBUF *out, UNUSED(Node *node), asmNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Asm: ");
+     gbprintf(out, "Asm: ");
 
-     if (u->tq) {
+     if (tq_has_anything(u->tq)) {
 	  PrintCRSpaces(out, offset + 2);
-	  PrintTQ(out, u->tq);
+	  PrintTQ(out, u->tq, offset, norecurse);
      }
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->template, offset + 2);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: output operands", out);
+     gbputs("List: output operands", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->output, offset + 4);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: input operands", out);
+     gbputs("List: input operands", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->input, offset + 4);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: clobbered registers", out);
+     gbputs("List: clobbered registers", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->clobbered, offset + 4);
 }
-PRIVATE inline void PrintAsmArg(FILE *out, UNUSED(Node *node), asmargNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintAsmArg(GBUF *out, UNUSED(Node *node), asmargNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "AsmArg: ");
+     gbprintf(out, "AsmArg: ");
      PrintCRSpaces(out, offset + 2);
-     fputs("Constraint:", out);
+     gbputs("Constraint:", out);
      PrintNode(out, u->constraint, offset + 2);
      PrintCRSpaces(out, offset + 2);
-     fputs("Expr:", out);
+     gbputs("Expr:", out);
      PrintNode(out, u->expr, offset + 2);
 }
 
@@ -607,14 +607,14 @@
 /*                            GCC stdarg.h support                       */
 /*                                                                       */
 /*************************************************************************/
-PRIVATE inline void PrintBuiltinVaArg(FILE *out, UNUSED(Node *node), builtinvaargNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintBuiltinVaArg(GBUF *out, UNUSED(Node *node), builtinvaargNode *u, int offset, UNUSED(Bool norecurse))
 {
-    fprintf(out, "builtinvaarg: ");
+    gbprintf(out, "builtinvaarg: ");
     PrintCRSpaces(out, offset + 2);
-    fputs("Expr:", out);
+    gbputs("Expr:", out);
     PrintNode(out, u->expr, offset + 2);
     PrintCRSpaces(out, offset + 2);
-    fputs("Type:", out);
+    gbputs("Type:", out);
     PrintNode(out, u->type, offset + 2);
 }
 
@@ -624,9 +624,9 @@
 /*                                                                       */
 /*************************************************************************/
 
-PRIVATE inline void PrintSpawn(FILE *out, UNUSED(Node *node), spawnNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintSpawn(GBUF *out, UNUSED(Node *node), spawnNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "Spawn: ");
+     gbprintf(out, "Spawn: ");
 
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->receiver, offset + 2);
@@ -635,62 +635,62 @@
      PrintNode(out, u->name, offset + 2);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: args", out);
+     gbputs("List: args", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->args, offset + 4);
 }
 
-PRIVATE inline void PrintSync(FILE *out, UNUSED(Node *node), UNUSED(syncNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintSync(GBUF *out, UNUSED(Node *node), UNUSED(syncNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Sync");
+     gbprintf(out, "Sync");
 }
 
-PRIVATE inline void PrintInletCall(FILE *out, UNUSED(Node *node), inletcallNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintInletCall(GBUF *out, UNUSED(Node *node), inletcallNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fprintf(out, "InletCall: ");
+     gbprintf(out, "InletCall: ");
 
      PrintCRSpaces(out, offset + 2);
      PrintNode(out, u->name, offset + 2);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: args", out);
+     gbputs("List: args", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->args, offset + 4);
 }
 
-PRIVATE inline void PrintAbort(FILE *out, UNUSED(Node *node), UNUSED(abortNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintAbort(GBUF *out, UNUSED(Node *node), UNUSED(abortNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Abort");
+     gbprintf(out, "Abort");
 }
 
-PRIVATE inline void PrintSynched(FILE *out, UNUSED(Node *node), UNUSED(synchedNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
+PRIVATE inline void PrintSynched(GBUF *out, UNUSED(Node *node), UNUSED(synchedNode *u), UNUSED(int offset), UNUSED(Bool norecurse))
 {
-     fprintf(out, "Synched");
+     gbprintf(out, "Synched");
 }
 
 
-PRIVATE inline void PrintXBlock(FILE *out, UNUSED(Node *node), XBlockNode *u, int offset, UNUSED(Bool norecurse))
+PRIVATE inline void PrintXBlock(GBUF *out, UNUSED(Node *node), XBlockNode *u, int offset, UNUSED(Bool norecurse))
 {
-     fputs("XBlock:", out);
-     if (node->parenthesized) fprintf(out, " parenthesized");
+     gbputs("XBlock:", out);
+     if (node->parenthesized) gbprintf(out, " parenthesized");
      PrintCRSpaces(out, offset + 2);
      if (u->type) {
-	 fprintf(out, "Type: (%d)", u->type->print_uid);
+	 gbprintf(out, "Type: (%d)", u->type->print_uid);
      } else {
-	 fprintf(out, "Type: nil");
+	 gbprintf(out, "Type: nil");
      }
 #if 0
-     fputs("Type:", out);
+     gbputs("Type:", out);
 #endif
      PrintCRSpaces(out, offset + 4);
      PrintNode(out, u->type, offset + 4);
      PrintCRSpaces(out, offset + 2);
-     fputs("List: decl", out);
+     gbputs("List: decl", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->decl, offset + 4);
 
      PrintCRSpaces(out, offset + 2);
-     fputs("List: stmts", out);
+     gbputs("List: stmts", out);
      PrintCRSpaces(out, offset + 4);
      PrintList(out, u->stmts, offset + 4);
 }
@@ -720,32 +720,32 @@
 }
 
 
-GLOBAL void PrintWildcard(FILE *out, Node *node, int offset) {
+GLOBAL void PrintWildcard(GBUF *out, Node *node, int offset) {
   
   PrintCRSpaces(out, offset);
   switch (node->wTyp) {
   case WildcardE:  
-    fprintf(out, "WildcardE: ");
+    gbprintf(out, "WildcardE: ");
     break;
   case WildcardD:  
-    fprintf(out, "WildcardD: ");
+    gbprintf(out, "WildcardD: ");
     break;
   case WildcardT:
-    fprintf(out, "WildcardT: ");
+    gbprintf(out, "WildcardT: ");
     break;
   default:
-    fprintf(out, "Unknown wildcard.");
+    gbprintf(out, "Unknown wildcard.");
   }
 }
 
 
 
-GLOBAL void PrintNode(FILE *out, Node *node, int offset)
+GLOBAL void PrintNode(GBUF *out, Node *node, int offset)
 {
   Bool norecurse;
 
   if (node == NULL) {
-    fprintf(out, "nil");
+    gbprintf(out, "nil");
     return;
   }
   if (PrintInvocations++ == 0) {
@@ -773,7 +773,7 @@
   --PrintInvocations;
 }
 
-GLOBAL void PrintList(FILE *out, List *list, int offset)
+GLOBAL void PrintList(GBUF *out, List *list, int offset)
 {
      ListMarker marker;
      Node *item;
@@ -791,7 +791,7 @@
 	  if (firstp == TRUE)
 	       firstp = FALSE;
 	  else if (offset < 0)
-	       fputs("\n\n", out);
+	       gbputs("\n\n", out);
 	  else
 	       PrintCRSpaces(out, offset);
 
@@ -799,7 +799,7 @@
      }
 
      if (firstp == TRUE)
-	  fputs("nil", out);
+	  gbputs("nil", out);
 
      --PrintInvocations;
 }
@@ -810,7 +810,7 @@
 /*                                                                       */
 /*************************************************************************/
 
-int print_float(FILE *fd, float val)
+GLOBAL int print_float(GBUF *fd, float val)
 {
      int i;
      char fmt[8];
@@ -828,10 +828,10 @@
 	  assert(i < 20);
      }
 
-     return fprintf(fd, "%s", buf);
+     return gbprintf(fd, "%s", buf);
 }
 
-int print_double(FILE *fd, double val)
+GLOBAL int print_double(GBUF *fd, double val)
 {
      int i;
      char fmt[8];
@@ -849,79 +849,19 @@
 	  assert(i < 20);
      }
 
-     return fprintf(fd, "%s", buf);
+     return gbprintf(fd, "%s", buf);
 }
 
-GLOBAL int PrintConstant(FILE *out, Node *c, Bool with_name)
+void PrintCRSpaces(GBUF *out, int spaces)
 {
-     int len = 0;
-
-     if (with_name)
-	  switch (c->u.Const.type->typ) {
-	      case Prim:
-		   len = PrintPrimType(out, c->u.Const.type, 0) + 1;
-		   fputc(' ', out);
-		   break;
-		   /* Used for strings */
-	      case Adcl:
-		   assert(c->u.Const.type->u.adcl.type->typ == Prim);
-		   fprintf(out, "array of ");
-		   len = PrintPrimType(out, c->u.Const.type->u.adcl.type, 0) + 10;
-		   fputc(' ', out);
-		   break;
-	      default:
-		   len = fprintf(out, "??? ");
-	  }
-     switch (c->u.Const.type->typ) {
-	 case Prim:
-	      switch (c->u.Const.type->u.prim.basic) {
-		  case Sint:
-		       return len + fprintf(out, "%d", c->u.Const.value.i);
-
-		       /*Manish 2/3 hack to print pointer constants */
-		  case Uint:
-		       return len + fprintf(out, "%uU", c->u.Const.value.u);
-		  case Slong:
-		       return len + fprintf(out, "%ldL", c->u.Const.value.l);
-		  case Ulong:
-		       return len + fprintf(out, "%luUL", c->u.Const.value.ul);
-		  case Float:
-		       return len + print_float(out, c->u.Const.value.f);
-		  case Double:
-		       return len + print_double(out, c->u.Const.value.d);
-		  case Char:
-		  case Schar:
-		  case Uchar:
-		       return len + PrintChar(out, c->u.Const.value.i);
-
-		  default:
-		       Fail(__FILE__, __LINE__, "");
-		       return 0;
-	      }
-
-	      /* Manish 2/3  Print Constant Pointers */
-	 case Ptr:
-	      return len + fprintf(out, "%u", c->u.Const.value.u);
-	      /* Used for strings */
-	 case Adcl:
-	      return len + PrintString(out, c->u.Const.value.s);
-
-	 default:
-	     FAIL("Unrecognized constant type");
-     }
-}
-
-void PrintCRSpaces(FILE *out, int spaces)
-{
-     fputc('\n', out);
-     while (spaces--)
-	  fputc(' ', out);
+     gbputs("\n", out);
+     PrintSpaces(out, spaces);
 }
 
-void PrintSpaces(FILE *out, int spaces)
+void PrintSpaces(GBUF *out, int spaces)
 {
      while (spaces--)
-	  fputc(' ', out);
+	 gbputs(" ", out);
 }
 
 GLOBAL void CharToText(char *array, unsigned char value)
@@ -943,50 +883,50 @@
      }
 }
 
-GLOBAL inline int PrintChar(FILE *out, int value)
+GLOBAL inline int PrintChar(GBUF *out, int value)
 {
      switch (value) {
 	 case '\n':
-	      return fprintf(out, "\\n");
+	      return gbprintf(out, "\\n");
 	 case '\t':
-	      return fprintf(out, "\\t");
+	      return gbprintf(out, "\\t");
 	 case '\v':
-	      return fprintf(out, "\\v");
+	      return gbprintf(out, "\\v");
 	 case '\b':
-	      return fprintf(out, "\\b");
+	      return gbprintf(out, "\\b");
 	 case '\r':
-	      return fprintf(out, "\\r");
+	      return gbprintf(out, "\\r");
 	 case '\f':
-	      return fprintf(out, "\\f");
+	      return gbprintf(out, "\\f");
 	 case '\a':
-	      return fprintf(out, "\\a");
+	      return gbprintf(out, "\\a");
 	 case '\\':
-	      return fprintf(out, "\\\\");
+	      return gbprintf(out, "\\\\");
 	 case '\?':
-	      return fprintf(out, "\\\?");
+	      return gbprintf(out, "\\\?");
 	 case '\"':
-	      return fprintf(out, "\\\"");
+	      return gbprintf(out, "\\\"");
 	 case '\'':
-	      return fprintf(out, "\\\'");
+	      return gbprintf(out, "\\\'");
 	 default:
 	      if (isprint(value)) {
-		   fputc(value, out);
+		   gbprintf(out, "%c", value);
 		   return 1;
 	      } else {
-		   return fprintf(out, "\\%o", value);
+		   return gbprintf(out, "\\%o", value);
 	      }
      }
 }
 
-GLOBAL int PrintString(FILE *out, const char *s)
+GLOBAL int PrintString(GBUF *out, const char *s)
 {
      int len = 0;
 
-     fputc('\"', out);
+     gbputs("\"", out);
      while (*s != 0) {
 	  len += PrintChar(out, *s++);
      }
-     fputc('\"', out);
+     gbputs("\"", out);
 
      return len + 2;
 }
diff -Nur 5.4.2.2/cilk2c/procedure.c current.Bug188/cilk2c/procedure.c
--- 5.4.2.2/cilk2c/procedure.c	2004-10-23 03:26:46.000000000 +0000
+++ current.Bug188/cilk2c/procedure.c	2005-10-22 02:52:37.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/procedure.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/procedure.c $ $LastChangedBy: bradley $ $Rev: 2450 $ $Date$");
 
 #include "conversions.h"	/* for UsualUnaryConversionsType */
 
@@ -101,8 +101,11 @@
       * 'cilk int' !  - athena
       *
       * BTW, the following line is a hack :-)
+      *   ((ofdcl->u.fdcl.tq ^ nfdcl->u.fdcl.tq) & (T_PROCEDURE | T_INLET))
+      * Bradley rewrote it has follows:
       */
-     if ((ofdcl->u.fdcl.tq ^ nfdcl->u.fdcl.tq) & (T_PROCEDURE | T_INLET))
+     if ((tq_has_procedure(ofdcl->u.fdcl.tq) != tq_has_procedure(nfdcl->u.fdcl.tq))
+	 || (tq_has_inlet(ofdcl->u.fdcl.tq) != tq_has_inlet(nfdcl->u.fdcl.tq)))
 	  goto Mismatch;
 
      /* The Result Type must be equal */
@@ -337,9 +340,9 @@
 
      decl = FinishDecl(decl);
      if (Level == 0)
-	  NodeSetDeclLocation(decl, T_TOP_DECL);
+	  NodeSetDeclLocation(decl, TQ_TOP_DECL);
      else
-	  NodeSetDeclLocation(decl, T_BLOCK_DECL);
+	  NodeSetDeclLocation(decl, TQ_BLOCK_DECL);
 
      /* 
       * We know that this is a function definition, rather than merely a
@@ -365,8 +368,8 @@
 	  IterateList(&marker, fdcl->u.fdcl.args);
 	  while (NextOnList(&marker, (GenericREF) & arg))
 	       if (arg->typ == Id)
-		    ConvertIdToDecl(arg, T_FORMAL_DECL,
-			       MakeDefaultPrimType(EMPTY_TQ, arg->coord),
+		    ConvertIdToDecl(arg, TQ_FORMAL_DECL,
+				    MakeDefaultPrimType(EMPTY_TQ, arg->coord),
 				    NULL, NULL);
 
 
@@ -527,7 +530,7 @@
 	       WarningCoord(2, id->coord,
 			    "parameter `%s' defaults to signed int",
 			    id->u.id.text);
-	       ConvertIdToDecl(id, T_FORMAL_DECL,
+	       ConvertIdToDecl(id, TQ_FORMAL_DECL,
 			       MakeDefaultPrimType(EMPTY_TQ, id->coord),
 			       NULL, NULL);
 	  }
@@ -556,8 +559,8 @@
      /* Set the type */
      IterateList(&il, ids);
      while (NextOnList(&il, (GenericREF) & id))
-	  ConvertIdToDecl(id, T_FORMAL_DECL,
-		   MakeDefaultPrimType(EMPTY_TQ, id->coord), NULL, NULL);
+	 ConvertIdToDecl(id, TQ_FORMAL_DECL,
+			 MakeDefaultPrimType(EMPTY_TQ, id->coord), NULL, NULL);
 
      return decl;
 }
diff -Nur 5.4.2.2/cilk2c/profile.c current.Bug188/cilk2c/profile.c
--- 5.4.2.2/cilk2c/profile.c	2004-10-23 03:26:18.000000000 +0000
+++ current.Bug188/cilk2c/profile.c	2005-10-22 02:52:37.000000000 +0000
@@ -20,7 +20,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/profile.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/profile.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 /* ProfileProgram should convert a type-checked C (or Cilk) tree into a tree with profiling added.
  *
@@ -69,7 +69,7 @@
 
 PRIVATE Node *BuildProfileRead(Node *addressnode, Node *node_to_take_sizeof, Coord coord) {
     return MakeCall(MakeId(ProfileReadName),
-		    List4(MakeCast(MakePtr(T_CONST, MakePrim(T_CONST, Void)),
+		    List4(MakeCast(MakePtr(TQ_CONST, MakePrim(TQ_CONST, Void)),
 				   addressnode),
 			  MakeUnary(SIZEOF, node_to_take_sizeof),
 			  MakeImplicitCast(MakePtr(EMPTY_TQ, MakePrim(EMPTY_TQ, Char)),
@@ -79,7 +79,7 @@
 
 PRIVATE Node *BuildProfileWrite(Node *addressnode, Node *node_to_take_sizeof, Coord coord) {
     return MakeCall(MakeId(ProfileWriteName),
-		    List4(MakeCast(MakePtr(T_CONST, MakePrim(T_CONST, Void)),
+		    List4(MakeCast(MakePtr(TQ_CONST, MakePrim(TQ_CONST, Void)),
 				   addressnode),
 			  MakeUnary(SIZEOF, node_to_take_sizeof),
 			  MakeImplicitCast(MakePtr(EMPTY_TQ, MakePrim(EMPTY_TQ, Char)),
@@ -94,9 +94,9 @@
 }
 
 
-PRIVATE void MyNodeAddTq(Node *node, TypeQual tq) {
-    NodeAddTq(node, tq & ~T_SUE_ELABORATED); /* Never stick SUE_ELABORATED on anything.*/
-}
+//PRIVATE void MyNodeAddTq(Node *node, TypeQual tq) {
+//    NodeUpdateTq2(node, tq_union, tq_remove_sue_elaborated(tq)); /* Never stick SUE_ELABORATED on anything.*/
+//}
 
 
 PRIVATE const char *create_unique_identifier (Node *var, const char *root) {
@@ -388,7 +388,7 @@
 		    /* Tested*/
 		    Node *decl  = MakeDecl(NULL, EMPTY_TQ, SetCoords(NodeCopy(NodeDataType(u->left), Subtree), UnknownCoord, Subtree), u->left, NULL);
 		    Node *newid = MakeId(create_unique_identifier(decl, "__addressCC"));
-		    MyNodeAddTq(decl->u.decl.type, T_CONST);
+		    NodeUpdateTq(decl->u.decl.type, tq_add_const);
 		    return MakeBlock(NodeCopy(u->type, Subtree),
 				     List1(decl),
 				     List2(BuildProfileRead(newid,
@@ -413,11 +413,12 @@
 		    Node *idbasetype = SetCoords(NodeCopy(NodeDataType(node), Subtree), UnknownCoord, Subtree);
 		    Node *decl = MakeDecl(NULL,
 					  EMPTY_TQ,
-					  MakePtr(T_CONST, idbasetype),
+					  MakePtr(TQ_CONST, idbasetype),
 					  MakeUnary(ADDRESS, node),
 					  NULL);
 		    Node *newid = MakeId(create_unique_identifier(decl, "__addressBB"));
-		    MyNodeAddTq(idbasetype, NodeTypeQuals(leftbasetype));
+		    NodeUpdateTq2(idbasetype, tq_union,
+				  tq_remove_sue_elaborated(NodeTypeQuals(leftbasetype))); /* Never stick SUE_ELABORATED on anything. */
 		    return MakeBlock(NodeCopy(u->type, Subtree),
 				     List1(decl),
 				     List2(BuildProfileRead(newid,
@@ -524,7 +525,7 @@
     case INDIR:
 	u->expr=ProfileNode(u->expr, TRUE);
 	if (readvalue) {
-	    Node *decl = MakeDecl(NULL, EMPTY_TQ, MakePtr(T_CONST, SetCoords(NodeCopy(u->type, Subtree), UnknownCoord, Subtree)), NULL, NULL);
+	    Node *decl = MakeDecl(NULL, EMPTY_TQ, MakePtr(TQ_CONST, SetCoords(NodeCopy(u->type, Subtree), UnknownCoord, Subtree)), NULL, NULL);
 	    const char *addr_var = create_unique_identifier(decl, "__addressAA");
 	    Node *newid = MakeId(addr_var);
 	    newid->u.id.decl = decl;
@@ -560,7 +561,7 @@
     case POSTDEC:
 	if (!lvalue_is_memory(u->expr)) return node;
 	else {
-	    Node *decl = MakeDecl(NULL, EMPTY_TQ, MakePtr(T_CONST, SetCoords(NodeCopy(u->type, Subtree), UnknownCoord, Subtree)), NULL, NULL);
+	    Node *decl = MakeDecl(NULL, EMPTY_TQ, MakePtr(TQ_CONST, SetCoords(NodeCopy(u->type, Subtree), UnknownCoord, Subtree)), NULL, NULL);
 	    const char *addr_var = create_unique_identifier(decl, "__addressFF");
 	    Node *newid = MakeId(addr_var);
 	    newid->u.id.decl = decl;
@@ -837,7 +838,7 @@
 }
 
 PRIVATE Node *ProfileDecl(Node *node, declNode *u, UNUSED(Bool readvalue)) {
-    if (NodeDeclLocation(node)==T_TOP_DECL
+    if (tq_has_top_decl(NodeDeclLocation(node))
 	|| DeclIsStatic(node)) 
 	return node;
     /*u->type=ProfileNode(u->type);*/
@@ -860,7 +861,7 @@
 		break;
 	    default:
 		fprintf(stderr, "What is this decl (%s:%d)\n", __FILE__, __LINE__);
-		PrintNode(stderr, item, 0);
+		fPrintNode(stderr, item, 0);
 		abort();
 	    }
 	}
@@ -879,18 +880,18 @@
     return JoinLists(List2(MakeDecl(ProfileReadName,
 				    EMPTY_TQ,
 				    MakeFdcl(EMPTY_TQ,
-					     List4(MakePtr(T_CONST, MakePrim(T_CONST, Void)),
+					     List4(MakePtr(TQ_CONST, MakePrim(TQ_CONST, Void)),
 						   MakePrim(EMPTY_TQ, Uint),
-						   MakePtr(EMPTY_TQ, MakePrim(T_CONST, Char)),
+						   MakePtr(EMPTY_TQ, MakePrim(TQ_CONST, Char)),
 						   MakePrim(EMPTY_TQ, Uint)),
 					     MakePrim(EMPTY_TQ, Void)),
 				    NULL, NULL),
 			   MakeDecl(ProfileWriteName,
 				    EMPTY_TQ,
 				    MakeFdcl(EMPTY_TQ,
-					     List4(MakePtr(T_CONST, MakePrim(T_CONST, Void)),
+					     List4(MakePtr(TQ_CONST, MakePrim(TQ_CONST, Void)),
 						   MakePrim(EMPTY_TQ, Uint),
-						   MakePtr(EMPTY_TQ, MakePrim(T_CONST, Char)),
+						   MakePtr(EMPTY_TQ, MakePrim(TQ_CONST, Char)),
 						   MakePrim(EMPTY_TQ, Uint)),
 					     MakePrim(EMPTY_TQ, Void)),
 				    NULL, NULL)),
diff -Nur 5.4.2.2/cilk2c/sem-check.c current.Bug188/cilk2c/sem-check.c
--- 5.4.2.2/cilk2c/sem-check.c	2004-10-23 03:26:43.000000000 +0000
+++ current.Bug188/cilk2c/sem-check.c	2005-10-22 02:52:37.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/sem-check.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/sem-check.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 #include "conversions.h"
 #include "initializer.h"
@@ -112,7 +112,7 @@
 	       NodeSetConstantValue(node, NodeGetConstantValue(decl->u.decl.init));
 	  }
 
-	  if (tq & T_CILKONLY) {
+	  if (tq_has_cilkonly(tq)) {
 	       if (in_procedure || in_inlet) {
 		    /* ok */
 	       } else {
@@ -293,7 +293,7 @@
          case REAL:
   	      u->type = NodeCopy(NodeDataType(u->expr), NodeOnly);
 	      /* Now would be a good time to make sure that it actually is a number of some sort. */
-              NodeRemoveTq(u->type, T_COMPLEX);
+	      NodeUpdateTq(u->type, tq_remove_complex);
 	      break;
 
 	      /* Function or object lvalue.  Returns PTR to T */
@@ -442,9 +442,9 @@
 {
      if (call_type->typ == Fdcl) {
 	  SemCheckCallArgs(node, call_type->u.fdcl.args, u->args);
-	  if (call_type->u.fdcl.tq & T_PROCEDURE)
+	  if (tq_has_procedure(call_type->u.fdcl.tq))
 	       SyntaxErrorCoord(node->coord, "use spawn to call a cilk procedure");
-	  else if (call_type->u.fdcl.tq & T_INLET)
+	  else if (tq_has_inlet(call_type->u.fdcl.tq))
 	       SyntaxErrorCoord(node->coord, "inlets must have a spawned argument");
      } else if (call_type->typ == Ptr) {
 	  return SemCheckCall1(node, u, NodeDataType(call_type->u.ptr.type));
@@ -753,21 +753,21 @@
 
 PRIVATE Node *SemCheckSdcl(Node *node, sdclNode *u)
 {
-     if (SUE_ELABORATED(u->tq))
+     if (tq_has_sue_elaborated(u->tq))
 	  StructCheckFields(u->type);
      return node;
 }
 
 PRIVATE Node *SemCheckUdcl(Node *node, udclNode *u)
 {
-     if (SUE_ELABORATED(u->tq))
+     if (tq_has_sue_elaborated(u->tq))
 	  UnionCheckFields(u->type);
      return node;
 }
 
 PRIVATE Node *SemCheckEdcl(Node *node, edclNode *u)
 {
-     if (SUE_ELABORATED(u->tq))
+     if (tq_has_sue_elaborated(u->tq))
 	  AssignEnumValues(u->type);
      return node;
 }
@@ -785,7 +785,7 @@
      u->bitsize = SemCheckNode(u->bitsize);
 
      if (u->init)
-	  SemCheckDeclInit(node, NodeDeclLocation(node) == T_BLOCK_DECL);
+	  SemCheckDeclInit(node, tq_has_block_decl(NodeDeclLocation(node)));
      else {
 	  /* catch unsized arrays in blocks */
 	  if (DeclIsBlock(node) 
@@ -793,18 +793,18 @@
 	       NodeSizeof(node, u->type, FALSE);
      }
 
-     if (u->tq & T_SHARED) {
-	  if (u->tq & T_PRIVATE)
+     if (tq_has_shared(u->tq)) {
+	  if (tq_has_private(u->tq))
 	       SyntaxErrorCoord(node->coord,
 				"variable `%s' cannot be both shared and private", u->name);
-	  if (NodeDeclLocation(node) != T_TOP_DECL)
+	  if (!tq_has_top_decl(NodeDeclLocation(node)))
 	       SyntaxErrorCoord(node->coord,
 				"only global variables can be shared");
 	  if (u->type->typ == Fdcl)
 	       SyntaxErrorCoord(node->coord,
 			 "functions cannot be declared shared", u->name);
-     } else if (u->tq & T_PRIVATE) {
-	  if (NodeDeclLocation(node) != T_TOP_DECL)
+     } else if (tq_has_private(u->tq)) {
+	 if (!tq_has_top_decl(NodeDeclLocation(node)))
 	       SyntaxErrorCoord(node->coord,
 				"only global variables can be private");
 	  if (u->type->typ == Fdcl)
@@ -851,7 +851,7 @@
 		    } else if (IsEllipsis(item));
 		    else {
 			 fprintf(stderr, "Unrecognized parameter\n");
-			 PrintNode(stderr, item, 0);
+			 fPrintNode(stderr, item, 0);
 			 fprintf(stderr, "\n");
 			 assert(FALSE);
 		    }
@@ -861,13 +861,13 @@
      save_in_procedure = in_procedure;
      save_in_inlet = in_inlet;
 
-     if (TYPE_QUALS(u->decl->u.decl.type->u.fdcl.tq) & T_PROCEDURE) {
-	  if (DECL_LOCATION(u->decl->u.decl.tq) != T_TOP_DECL)
+     if (tq_has_procedure(tq_type_quals(u->decl->u.decl.type->u.fdcl.tq))) {
+	 if (!tq_has_top_decl(tq_decl_location(u->decl->u.decl.tq)))
 	       SyntaxErrorCoord(node->coord, "cilk procedure must be defined at top level");
-	  if (TYPE_QUALS(u->decl->u.decl.type->u.fdcl.tq) & T_INLET)
+	  if (tq_has_inlet(tq_type_quals(u->decl->u.decl.type->u.fdcl.tq)))
 	       SyntaxErrorCoord(node->coord, "cilk procedure cannot be an inlet");
 	  in_procedure = 1;
-     } else if (TYPE_QUALS(u->decl->u.decl.type->u.fdcl.tq) & T_INLET) {
+     } else if (tq_has_inlet(tq_type_quals(u->decl->u.decl.type->u.fdcl.tq))) {
 	  if (!in_procedure)
 	       SyntaxErrorCoord(node->coord,
 			"inlet must be defined inside a cilk procedure");
@@ -942,7 +942,7 @@
      type = NodeDataType(type);
      if (type->typ == Fdcl) {
 	  TypeQual tq = NodeTq(type);
-	  return (tq & T_PROCEDURE) != 0;
+	  return tq_has_procedure(tq);
      } else
 	  return FALSE;
 }
@@ -953,7 +953,7 @@
      type = NodeDataType(type);
      if (type->typ == Fdcl) {
 	  TypeQual tq = NodeTq(type);
-	  return (tq & T_INLET) != 0;
+	  return tq_has_inlet(tq);
      } else
 	  return FALSE;
 }
@@ -1783,7 +1783,7 @@
      rtype = NodeDataType(right);
 
      if (ltype == NULL) {
-	  PrintNode(stdout, left, 0);
+	  fPrintNode(stdout, left, 0);
 	  printf("\n");
      }
      assert(left);
diff -Nur 5.4.2.2/cilk2c/simplify.c current.Bug188/cilk2c/simplify.c
--- 5.4.2.2/cilk2c/simplify.c	2004-10-23 03:26:46.000000000 +0000
+++ current.Bug188/cilk2c/simplify.c	2005-10-22 02:52:38.000000000 +0000
@@ -20,7 +20,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/simplify.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/simplify.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 /* The simplifications we do are as follows
  *   Get rid of casts on lvalues.  Thus
@@ -189,9 +189,9 @@
 		    u->left->u.array.type = ltype->u.adcl.type;
 		} else {
 		    fprintf(stderr, "Failing because I have an arrow from a nonpointer type: \n");
-		    PrintNode(stderr, ltype, 0);
+		    fPrintNode(stderr, ltype, 0);
 		    fprintf(stderr, "\nin this expression:\n");
-		    PrintNode(stderr, node, 0);
+		    fPrintNode(stderr, node, 0);
 		}
 	    }
 	    break;
diff -Nur 5.4.2.2/cilk2c/sue.c current.Bug188/cilk2c/sue.c
--- 5.4.2.2/cilk2c/sue.c	2004-10-23 03:26:46.000000000 +0000
+++ current.Bug188/cilk2c/sue.c	2005-10-22 02:52:37.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/sue.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/sue.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 
      
@@ -59,30 +59,30 @@
      return (create);
 }
 
-GLOBAL void PrintSUE(FILE *out, SUEtype *sue, int offset, Bool recursep)
+GLOBAL void PrintSUE(GBUF *out, SUEtype *sue, int offset, Bool recursep)
 {
      ListMarker marker;
      Node *decl;
      const char *name;
 
      if (sue == NULL) {
-	  fprintf(out, "Null SUE");
+	  gbprintf(out, "Null SUE");
 	  return;
      }
      name = (sue->name) ? sue->name : "nil";
 
      switch (sue->typ) {
 	 case Sdcl:
-	      fprintf(out, "struct %s (%d)", name, sue->size);
+	      gbprintf(out, "struct %s (%d)", name, sue->size);
 	      break;
 	 case Udcl:
-	      fprintf(out, "union %s", name);
+	      gbprintf(out, "union %s", name);
 	      break;
 	 case Edcl:
-	      fprintf(out, "enum %s", name);
+	      gbprintf(out, "enum %s", name);
 	      break;
 	 default:
-	      fprintf(out, "unexpected SUE type %d", sue->typ);
+	      gbprintf(out, "unexpected SUE type %d", sue->typ);
      }
 
      if (recursep) {
@@ -176,7 +176,7 @@
        sue->name = (OmitLookups() ? "___unnamed_sue_from_string" : InsertUniqueSymbol(Tags, sue, "___sue"));
      }
 
-     sudcl->u.sdcl.tq |= T_SUE_ELABORATED;
+     sudcl->u.sdcl.tq = tq_add_sue_elaborated(sudcl->u.sdcl.tq);
      sudcl->u.sdcl.type = sue;
 
      assert(sue->attributes==0);
@@ -216,7 +216,7 @@
 	  
      }
 
-     sudcl->u.sdcl.tq &= ~T_SUE_ELABORATED;
+     sudcl->u.sdcl.tq = tq_remove_sue_elaborated(sudcl->u.sdcl.tq);
      sudcl->u.sdcl.type = sue;
      return (sudcl);
 }
@@ -301,9 +301,9 @@
 
      new = MakeEdclCoord(EMPTY_TQ, sue, enum_coord);
      if (values)
-	  new->u.edcl.tq |= T_SUE_ELABORATED;
+	 new->u.edcl.tq = tq_add_sue_elaborated(new->u.edcl.tq);
      else
-	  new->u.edcl.tq &= ~T_SUE_ELABORATED;
+	 new->u.edcl.tq = tq_remove_sue_elaborated(new->u.edcl.tq);
 
      return new;
 }
@@ -360,8 +360,8 @@
 
 GLOBAL Node *BuildEnumConst(Node *name, Node *value)
 {
-     Node *decl = ConvertIdToDecl(name, T_ENUM_DECL,
-			       MakeDefaultPrimType(T_CONST, name->coord),
+     Node *decl = ConvertIdToDecl(name, TQ_ENUM_DECL,
+				  MakeDefaultPrimType(TQ_CONST, name->coord),
 				  value, NULL);
      if (!OmitLookups()) {
        InsertSymbol(Identifiers, decl->u.decl.name, decl,
diff -Nur 5.4.2.2/cilk2c/testEquals.c current.Bug188/cilk2c/testEquals.c
--- 5.4.2.2/cilk2c/testEquals.c	2004-10-23 03:26:43.000000000 +0000
+++ current.Bug188/cilk2c/testEquals.c	2005-10-22 02:52:37.000000000 +0000
@@ -98,7 +98,7 @@
   /* n2 = ParseStringIntoASTNode(input2);*/
   
   printf("The node: \n");
-  PrintNode(stdout, n1, 0);
+  fPrintNode(stdout, n1, 0);
   printf("\n\n");
 }
 
@@ -639,7 +639,7 @@
 	  printf("Error: ReplaceSyntaxSubtree TestCase %i: (%s, %s, %s) replace not %s. \n", i,
 		 testCases[4*i], testCases[4*i+1], testCases[4*i+2], testCases[4*i+3]);
 	  printf("The answer node we got back: \n");
-	  PrintNode(stdout, testResult, 0);
+	  fPrintNode(stdout, testResult, 0);
 	}
     }
   
@@ -729,11 +729,11 @@
 	numErrors++;
 	printf("Error in CopyAST TestCase %d: copying %s \n", i, testCases[2*i]);
 	printf("The copied result: \n");
-	PrintNode(stdout, copyTree, 0);
+	fPrintNode(stdout, copyTree, 0);
       	printf("\n");
 	
 	printf("The correct result: \n");
-	PrintNode(stdout, correctResult, 0);
+	fPrintNode(stdout, correctResult, 0);
 	printf("\n");
       }
     }    
@@ -1142,28 +1142,8 @@
 
   if (n != NULL) {
     printf("The list: \n");
-    PrintList(stdout, n, 0);
+    fPrintList(stdout, n, 0);
     printf("\n");
   }
 
 }
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff -Nur 5.4.2.2/cilk2c/transform.c current.Bug188/cilk2c/transform.c
--- 5.4.2.2/cilk2c/transform.c	2004-10-23 03:26:44.000000000 +0000
+++ current.Bug188/cilk2c/transform.c	2005-10-22 02:52:37.000000000 +0000
@@ -30,7 +30,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/transform.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/transform.c $ $LastChangedBy: bradley $ $Rev: 2462 $ $Date$");
 
 #include <ctype.h>
 #include "astEquals.h"
@@ -346,7 +346,7 @@
      assert(decl->typ == Decl);
      fdcl = decl->u.decl.type;
      assert(fdcl->typ == Fdcl);
-     return (TYPE_QUALS(fdcl->u.fdcl.tq) & T_INLET) ? 1 : 0;
+     return tq_has_inlet(fdcl->u.fdcl.tq);
 }
 
 /*
@@ -1294,21 +1294,21 @@
 			   NULL,
 			   NULL);
 	  worker_state = MakeDecl(WorkerStateName,
-				  T_FORMAL_DECL,
-				  MakePtr(T_CONST, MakeWorkerStateType()),
+				  TQ_FORMAL_DECL,
+				  MakePtr(TQ_CONST, MakeWorkerStateType()),
 				  NULL,
 				  NULL);
 	  AppendItem(u->args, frame);
 	  AppendItem(u->args, worker_state);
      }
 
-     if (u->tq & T_PROCEDURE) {
+     if (tq_has_procedure(u->tq)) {
 	  List *args;
 	  Node *n;
 	  args = u->args;
 	  n = MakeDecl(WorkerStateName,
-		       T_FORMAL_DECL,
-		       MakePtr(T_CONST, MakeWorkerStateType()),
+		       TQ_FORMAL_DECL,
+		       MakePtr(TQ_CONST, MakeWorkerStateType()),
 		       NULL,
 		       NULL);
 
@@ -1451,7 +1451,7 @@
 	  }
      }
      /* delete static declarations (they have been globalized) -KHR */
-     if (in_procedure && NodeStorageClass(node) == T_STATIC)
+     if (in_procedure && tq_has_static(NodeStorageClass(node)))
 	  return NULL;
 
      /*
@@ -1459,12 +1459,12 @@
       * frame) 
       */
      if (in_procedure && version == Slow)
-	  NodeRemoveTq(node->u.decl.type, T_CONST);
+	  NodeUpdateTq(node->u.decl.type, tq_remove_const);
 
      /*
       * Generate attribute for T_SHARED and T_PRIVATE variables
       */
-     if (NodeDeclQuals(node) & T_PRIVATE) {
+     if (tq_has_private(NodeDeclTq(node))) {
 	  if (GenerateSegments) {
 	       if (!HasConstQual(node))
 		    u->attribs =
@@ -1476,14 +1476,14 @@
 	  } else
 	       WarningCoord(2, node->coord,
 		   "`private' qualifier not supported on this target\n");
-     } else if (NodeDeclQuals(node) & T_SHARED ||
+     } else if (tq_has_shared(NodeDeclTq(node)) ||
 		(GenerateSegments &&
-		 NodeDeclLocation(node) == T_TOP_DECL &&
-		 NodeStorageClass(node) != T_EXTERN &&
-		 NodeStorageClass(node) != T_REGISTER &&
-		 NodeStorageClass(node) != T_TYPEDEF &&
+		 tq_has_top_decl(NodeDeclLocation(node)) &&
+		 !tq_has_extern(NodeStorageClass(node)) &&
+		 !tq_has_register(NodeStorageClass(node)) &&
+		 !tq_has_typedef(NodeStorageClass(node)) &&
 		 NodeDataType(node)->typ != Fdcl)) {
-	  if ((NodeDeclQuals(node) & T_SHARED) && !GenerateSegments) {
+	  if (tq_has_shared(NodeDeclTq(node)) && !GenerateSegments) {
 #if 0	       
 	       WarningCoord(2, node->coord,
 		    "`shared' qualifier not supported on this target\n");
@@ -1618,7 +1618,7 @@
      Node *inlet;
 
      if (!IsVoidType(FirstItem(decl->u.decl.type->u.fdcl.args))) {
-	  args_decl = MakeSdcl(EMPTY_TQ | T_SUE_ELABORATED,
+	  args_decl = MakeSdcl(TQ_SUE_ELABORATED,
 			       make_SUE(Sdcl,
 					MakeInletArgsTypeName(name),
 					decl->u.decl.type->u.fdcl.args));
@@ -1666,13 +1666,11 @@
 
      inlet_decl = ParseWildcardStringNode("static void %d(%t %d, %t *%d, %t *%d, %t *%d);",
 				     name,
-				     MakePtr(T_CONST, MakeWorkerStateType()), WorkerStateName,
+				     MakePtr(TQ_CONST, MakeWorkerStateType()), WorkerStateName,
 				     MakeFrameType(proc_name), FrameName,
 				     args_type, InletArgsName,
 				     NodeCopy(decl->u.decl.type->u.fdcl.returns, Subtree), InletResultName);
-     NodeAddTq(inlet_decl, T_SLOW_INLET);
-
-     
+     NodeUpdateTq(inlet_decl, tq_add_slow_inlet);
 					  
      if (args_decl)
 	  SetCoords(args_decl, node->coord, Subtree);
@@ -1701,7 +1699,7 @@
      Node *inlet;
 
      if (!IsVoidType(FirstItem(decl->u.decl.type->u.fdcl.args))) {
-	  args_decl = MakeSdcl(EMPTY_TQ | T_SUE_ELABORATED,
+	  args_decl = MakeSdcl(TQ_SUE_ELABORATED,
 			       make_SUE(Sdcl,
 					MakeInletArgsTypeName(name),
 					decl->u.decl.type->u.fdcl.args));
@@ -1713,8 +1711,8 @@
 
      inlet_type = MakeFdcl(EMPTY_TQ,
 			   List4(MakeDecl(WorkerStateName,
-					  T_FORMAL_DECL,
-					  MakePtr(T_CONST,
+					  TQ_FORMAL_DECL,
+					  MakePtr(TQ_CONST,
 						  MakeWorkerStateType()),
 					  NULL,
 					  NULL),
@@ -1740,7 +1738,7 @@
 			   MakePrim(EMPTY_TQ, Void));
 
      inlet_decl = MakeDecl(name,
-			   T_STATIC | T_SLOW_INLET,
+			   tq_add_static(TQ_SLOW_INLET),
 			   inlet_type,
 			   NULL,
 			   NULL);
@@ -1783,8 +1781,8 @@
 
      inlet_type = MakeFdcl(EMPTY_TQ,
 			   List4(MakeDecl(WorkerStateName,
-					  T_FORMAL_DECL,
-					  MakePtr(T_CONST,
+					  TQ_FORMAL_DECL,
+					  MakePtr(TQ_CONST,
 						  MakeWorkerStateType()),
 					  NULL,
 					  NULL),
@@ -1809,7 +1807,7 @@
 			   MakePrim(EMPTY_TQ, Void));
 
      inlet_decl = MakeDecl(name,
-			   T_STATIC | T_SLOW_INLET,
+			   tq_add_static(TQ_SLOW_INLET),
 			   inlet_type,
 			   NULL,
 			   NULL);
@@ -1840,7 +1838,7 @@
      }
      else {
           /* indicate this starts C code for CILK_WHERE_AM_I */
-          NodeAddTq(u->decl, T_C_CODE);
+	  NodeUpdateTq(u->decl, tq_add_c_code);
 	  curr_inlet = NULL;
 	  inlet_name = NULL;
      }
@@ -1853,9 +1851,9 @@
 
           /* Change the type qualifier into T_SLOW_INLET for CILK_WHERE_AM_I */
           if (version == Fast)
-	      NodeAddTq(u->decl, T_FAST_INLET);
+	       NodeUpdateTq(u->decl, tq_add_fast_inlet);
           if (version == Slow)
-	      NodeAddTq(u->decl, T_SLOW_INLET);
+	       NodeUpdateTq(u->decl, tq_add_slow_inlet);
 
 	  /* make standalone inlet */
 	  if (version == Slow)
@@ -2781,7 +2779,7 @@
 	  const char *tmp = MakeTempName();
 	  Node *returntype = node->u.Return.proc->u.proc.decl->u.decl.type->u.fdcl.returns;
 	  Node *decl = MakeDecl(tmp,
-				T_BLOCK_DECL,
+				TQ_BLOCK_DECL,
 				NodeCopy(returntype, Subtree),
 				node->u.Return.expr,
 				NULL);
@@ -2809,20 +2807,20 @@
 PRIVATE Node *MakeSlowDecl(const char *name)
 {
      Node *arg = MakeDecl(FrameName,
-			  T_FORMAL_DECL,
+			  TQ_FORMAL_DECL,
 			  MakePtr(EMPTY_TQ, MakeFrameType(name)),
 			  NULL,
 			  NULL);
 
      Node *ws = MakeDecl(WorkerStateName,
-			 T_FORMAL_DECL,
-			 MakePtr(T_CONST, MakeWorkerStateType()),
+			 TQ_FORMAL_DECL,
+			 MakePtr(TQ_CONST, MakeWorkerStateType()),
 			 NULL,
 			 NULL);
 
     Node *n =
 	  MakeDecl(MakeSlowProcName(name),
-		   T_STATIC | T_TOP_DECL | T_SLOW_PROCEDURE,
+		   tq_add_static(tq_add_top_decl(TQ_SLOW_PROCEDURE)),
 		   MakeFdcl(EMPTY_TQ, List2(ws, arg),
 			    MakePrim(EMPTY_TQ, Void)),
 		   NULL,
@@ -2838,12 +2836,12 @@
 
      n = NodeCopy(u->decl, Subtree);
      n->u.decl.name = MakeExportProcName(n->u.decl.name);
-     n->u.decl.tq = n->u.decl.tq | T_TOP_DECL | T_C_CODE;
+     n->u.decl.tq = tq_add_top_decl(tq_add_c_code(n->u.decl.tq));
      args = TransformList(n->u.decl.type->u.fdcl.args);
      /*printf("MakeExportDecl -name=%s\n", name);*/
      context = MakeDecl(ContextName,
-			 T_FORMAL_DECL,
-			 MakePtr(T_CONST, MakeContextType()),
+			 TQ_FORMAL_DECL,
+			 MakePtr(TQ_CONST, MakeContextType()),
 			 NULL,
 			 NULL);
 
@@ -2870,19 +2868,19 @@
 
      n = NodeCopy(u->decl, Subtree);
      n->u.decl.name = MakeImportProcName(n->u.decl.name);
-     n->u.decl.tq = T_STATIC | T_TOP_DECL | T_C_CODE;
+     n->u.decl.tq = tq_add_static(tq_add_top_decl(TQ_C_CODE));
      n->u.decl.type->u.fdcl.returns = MakePrim(EMPTY_TQ, Void);
      args = TransformList(n->u.decl.type->u.fdcl.args);
      returns = u->decl->u.decl.type->u.fdcl.returns;
 
      ws = MakeDecl(WorkerStateName,
-		   T_FORMAL_DECL,
-		   MakePtr(T_CONST, MakeWorkerStateType()),
+		   TQ_FORMAL_DECL,
+		   MakePtr(TQ_CONST, MakeWorkerStateType()),
 		   NULL,
 		   NULL);
 
      arg_struct = MakeDecl(ProcArgsName_v,
-			   T_FORMAL_DECL,
+			   TQ_FORMAL_DECL,
 			   MakePtr(EMPTY_TQ, NodeCopy(PrimVoid, Subtree)), /*MakeProcArgsType(u->decl->u.decl.name)),*/
 			   NULL,
 			   NULL);
@@ -2904,11 +2902,11 @@
 		     int scope_count)
 {
      TypeQual sc = NodeStorageClass(decl);
-     if (sc == T_EXTERN || sc == T_STATIC || sc == T_TYPEDEF ||
+     if (tq_has_extern(sc) || tq_has_static(sc) || tq_has_typedef(sc) ||
 	 decl->u.decl.type->typ == Fdcl)
 	  return;		/* leave as kind 0 */
 
-     if (scope_count > 0 && DECL_LOCATION(decl->u.decl.tq) == T_FORMAL_DECL) {
+     if (scope_count > 0 && tq_has_formal_decl(decl->u.decl.tq)) {
 	  /* inlet argument variable */
 	  decl->u.decl.kind = 4;
      } else if (FindItem(register_vars, decl)) {
@@ -3040,7 +3038,7 @@
      if (new->typ == Tdef) {
 	  if (LookupSymbol(Identifiers, new->u.tdef.name,
 			   (GenericREF) & junk)) {
-	       if (NodeStorageClass(junk) == T_TYPEDEF &&
+	       if (tq_has_typedef(NodeStorageClass(junk)) &&
 		   junk->u.decl.type == new->u.tdef.type)
 		    return new;	/* external declaration is OK */
 	  }
@@ -3058,7 +3056,7 @@
 	   * is this the right thing to do with tdef's type qualifiers? -
 	   *  KHR
 	   */
-	  NodeAddTq(new->u.tdef.type, new->u.tdef.tq);
+	  NodeUpdateTq2(new->u.tdef.type, tq_union, new->u.tdef.tq);
 	  return new->u.tdef.type;
      } else
 	  return new;
@@ -3108,7 +3106,7 @@
       * scopes in a oneof because only one is being used at a time.
       */
      fields = List1(MakeDecl(HeaderName,
-			     EMPTY_TQ | T_SU_DECL,
+			     TQ_SU_DECL,
 			     MakeGenericFrameType(),
 			     NULL,
 			     NULL));
@@ -3118,7 +3116,7 @@
      if (!IsVoidType(type) && !IsScalarType(type)) {
 	  fields = AppendItem(fields,
 			      MakeDecl(DummyReturnName,
-				       EMPTY_TQ | T_SU_DECL,
+				       TQ_SU_DECL,
 				       NodeCopy(type, Subtree),
 				       NULL,
 				       NULL));
@@ -3140,8 +3138,10 @@
 	       if (decl->u.decl.kind == 0)
 		    continue;
 	       SetCurrentOnList(&marker2, NodeCopy(decl, Subtree));
-	       NodeRemoveTq(decl, T_REGISTER);
-	       NodeRemoveTq(decl->u.decl.type, T_CONST);
+	       if (tq_has_register(decl->u.decl.tq)) { 
+		    decl->u.decl.tq = tq_remove_all_storage_classes(decl->u.decl.tq);
+	       }
+	       NodeUpdateTq(decl->u.decl.type, tq_remove_const);
 	       remove_unused_attribute(decl);
 	       decl->u.decl.type = ExpandTypedefs(decl->u.decl.type);
 	       decl->u.decl.init = NULL;
@@ -3152,9 +3152,9 @@
 	  if (scopefields)
 	       fields = AppendItem(fields,
 				   MakeDecl(MakeScopeName(scope_count),
-					    EMPTY_TQ | T_SU_DECL,
-				    MakeSdcl(EMPTY_TQ | T_SUE_ELABORATED,
-				      make_SUE(Sdcl, NULL, scopefields)),
+					    TQ_SU_DECL,
+					    MakeSdcl(TQ_SUE_ELABORATED,
+						     make_SUE(Sdcl, NULL, scopefields)),
 					    NULL,
 					    NULL));
 	  scope_count++;
@@ -3162,8 +3162,8 @@
 
      /* finally, make struct declaration for frame */
      result = MakeDecl(NULL,
-		       EMPTY_TQ | T_TOP_DECL,
-		       MakeSdcl(EMPTY_TQ | T_SUE_ELABORATED,
+		       TQ_TOP_DECL,
+		       MakeSdcl(TQ_SUE_ELABORATED,
 	make_SUE(Sdcl, MakeFrameTypeName(u->decl->u.decl.name), fields)),
 		       NULL,
 		       NULL);
@@ -3194,7 +3194,7 @@
      	returns = NodeCopy(fdcl->u.fdcl.returns, Subtree);
 
      	fields = ConsItem(  MakeDecl(ProcResultName,
-			    	     T_FORMAL_DECL,
+			    	     TQ_FORMAL_DECL,
 				     returns,
 				     NULL,
 				     NULL),
@@ -3203,7 +3203,7 @@
 
      /* Create the structure */
      if ( fields ) {
-	  args_decl = MakeSdcl(EMPTY_TQ | T_SUE_ELABORATED,
+	  args_decl = MakeSdcl(TQ_SUE_ELABORATED,
 			       make_SUE(Sdcl,
 					MakeProcArgsTypeName(decl->u.decl.name),
 					fields));
@@ -3225,7 +3225,7 @@
      USE_UNUSED(node);
      /* make CilkProcInfo declaration */
      linkage = MakeDecl(MakeLinkName(proc_name),
-			T_STATIC,
+			TQ_STATIC,
 			MakeAdcl(EMPTY_TQ,
 				 MakeTdef(EMPTY_TQ,
 					  UniqueString("CilkProcInfo")),
@@ -3289,7 +3289,7 @@
 
      return MakeBlock(NULL,
 		      List1(MakeDecl(FrameName,
-				     EMPTY_TQ | T_BLOCK_DECL,
+				     TQ_BLOCK_DECL,
 				     MakePtr(EMPTY_TQ,
 					     MakeFrameType(proc_name)),
 				     NULL,
@@ -3517,11 +3517,11 @@
      }
      switch (type->typ) {
 	 case Sdcl:
-	      return MakeSdcl(T_SUE_ELABORATED, type);
+	      return MakeSdcl(TQ_SUE_ELABORATED, type);
 	 case Udcl:
-	      return MakeUdcl(T_SUE_ELABORATED, type);
+	      return MakeUdcl(TQ_SUE_ELABORATED, type);
 	 case Edcl:
-	      return MakeEdcl(T_SUE_ELABORATED, type);
+	      return MakeEdcl(TQ_SUE_ELABORATED, type);
 	 default:
 	      FAIL("bad type in GlobalizeSUE");
 	      return NULL;
@@ -3538,26 +3538,26 @@
 
 	 switch (node->typ) {
 	 case Sdcl:
-	      if (SUE_ELABORATED(node->u.sdcl.tq)) {
+	      if (tq_has_sue_elaborated(node->u.sdcl.tq)) {
 		   new = GlobalizeSUE(node->u.sdcl.type);
-		   NodeRemoveTq(node, T_SUE_ELABORATED);
+		   NodeUpdateTq(node, tq_remove_sue_elaborated);
 	      }
 	      break;
 	 case Udcl:
-	      if (SUE_ELABORATED(node->u.udcl.tq)) {
+	      if (tq_has_sue_elaborated(node->u.udcl.tq)) {
 		   new = GlobalizeSUE(node->u.udcl.type);
-		   NodeRemoveTq(node, T_SUE_ELABORATED);
+		   NodeUpdateTq(node, tq_remove_sue_elaborated);
 	      }
 	      break;
 	 case Edcl:
-	      if (SUE_ELABORATED(node->u.edcl.tq)) {
+	      if (tq_has_sue_elaborated(node->u.edcl.tq)) {
 		   new = GlobalizeSUE(node->u.edcl.type);
-		   NodeRemoveTq(node, T_SUE_ELABORATED);
+		   NodeUpdateTq(node, tq_remove_sue_elaborated);
 	      }
 	      break;
 	 case Decl:
-	      if (NodeStorageClass(node) == T_STATIC &&
-		  NodeDeclLocation(node) == T_BLOCK_DECL) {
+	      if (tq_has_static(NodeStorageClass(node)) &&
+		  tq_has_block_decl(NodeDeclLocation(node))) {
 		   Node *junk;
 		   /* choose a globally unique name for this static *
 		    * variable */
@@ -3567,7 +3567,7 @@
 			InsertSymbol(Identifiers, node->u.decl.name, node, NULL);
 		   }
 		   new = node;
-		   NodeSetDeclLocation(new, T_TOP_DECL);
+		   NodeSetDeclLocation(new, TQ_TOP_DECL);
 		   new = TransformDecl(new, &new->u.decl);
 
 		   /* 
@@ -3631,7 +3631,8 @@
       * later as a top level function.
       */
      if ((node->typ == Proc) && 
-	 (node->u.proc.decl->u.decl.tq & (T_SLOW_INLET | T_FAST_INLET))) {
+	 (tq_has_slow_inlet(node->u.proc.decl->u.decl.tq) ||
+	  tq_has_fast_inlet(node->u.proc.decl->u.decl.tq))) {
 	  const char*   this_inlet_name = MakeInnerInletName(node->u.proc.decl->u.decl.name);
 	  const char*   short_name;
 
@@ -3890,7 +3891,7 @@
      fastnode->u.proc.decl->u.decl.name = MakeFastProcName( fastnode->u.proc.decl->u.decl.name );
 
      /* set fast decl flag */
-     NodeAddTq(fastnode->u.proc.decl, T_FAST_PROCEDURE);
+     NodeUpdateTq(fastnode->u.proc.decl, tq_add_fast_procedure);
 
      /* make slow procedure declaration */
      result = AppendItem(result,
@@ -3938,7 +3939,7 @@
 
      if (node->typ == Proc &&
 	 node->u.proc.decl->u.decl.type->typ == Fdcl &&
-	 node->u.proc.decl->u.decl.type->u.fdcl.tq & T_PROCEDURE) {
+	 tq_has_procedure(node->u.proc.decl->u.decl.type->u.fdcl.tq)) {
 	  /* cilk procedure */
 	  result = TransformCilkProc(node, &node->u.proc);
      } else
diff -Nur 5.4.2.2/cilk2c/type.c current.Bug188/cilk2c/type.c
--- 5.4.2.2/cilk2c/type.c	2004-10-23 03:26:21.000000000 +0000
+++ current.Bug188/cilk2c/type.c	2005-10-22 02:54:14.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/type.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/type.c $ $LastChangedBy: bradley $ $Rev: 2506 $ $Date$");
 
 
 PRIVATE Bool IsLvalue_Local(Node *node, Bool modifiablep);
@@ -97,7 +97,7 @@
      PrimFloat = MakePrim(EMPTY_TQ, Float);
      PrimDouble = MakePrim(EMPTY_TQ, Double);
      PrimLongdouble = MakePrim(EMPTY_TQ, Longdouble);
-     StaticString = MakePtr(EMPTY_TQ, MakePrim(T_STATIC, Char));
+     StaticString = MakePtr(EMPTY_TQ, MakePrim(TQ_STATIC, Char));
 
      /* Make some standard zeros */
      SintZero = MakeConstSint(0);
@@ -125,189 +125,77 @@
 /*                                                                       */
 /*************************************************************************/
 
-GLOBAL int TQtoText(char array[], TypeQual tq)
+GLOBAL void TQtoText(char array[], int arraysize, TypeQual tq)
+/* TQtoText is used only to produce diagnostics.  Hence there is no need for a full OutputContext. */
 {
-     array[0] = '\0';
-
-     if (tq & T_EXTENSION) {
-	 strcat(array, "__extension__ ");
-     }
-     switch (STORAGE_CLASS(tq)) {
-	 case T_TYPEDEF:
-	      strcat(array, "typedef ");
-	      break;
-	 case T_EXTERN:
-	      strcat(array, "extern ");
-	      break;
-	 case T_STATIC:
-	      strcat(array, "static ");
-	      break;
-	 case T_AUTO:
-	      strcat(array, "auto ");
-	      break;
-	 case T_REGISTER:
-	      strcat(array, "register ");
-	      break;
-	 case 0:		/* no explicit storage class */
-	      break;
-	 default:
-	      UNREACHABLE;
-     }
-
-     switch (DECL_LOCATION(tq)) {
-	 case T_TOP_DECL:
-	      strcat(array, "top_decl ");
-	      break;
-	 case T_BLOCK_DECL:
-	      strcat(array, "block_decl ");
-	      break;
-	 case T_FORMAL_DECL:
-	      strcat(array, "formal_decl ");
-	      break;
-	 case T_SU_DECL:
-	      strcat(array, "su_decl ");
-	      break;
-	 case T_ENUM_DECL:
-	      strcat(array, "enum_decl ");
-	      break;
-	 case 0:
-	      break;
-	 default:
-	      UNREACHABLE;
-     }
-
-     if (tq & T_REDUNDANT_EXTERNAL_DECL)
-	  strcat(array, "redundant_extern ");
+    GBUF *gb=make_string_gbuf(array,arraysize);
+    TQtoGBUF(gb, tq);
+}
 
-     if (tq & T_SHARED)
-	  strcat(array, "shared ");
-     if (tq & T_PRIVATE)
-	  strcat(array, "private ");
-
-     if (tq & T_INLINE) {
-          #ifdef inline
-/* This hacking is the standard CPP idiom for stringifying the result of a macro expansion.
- * In this case, the macro inline might be defined in ../config.h as
- *   #define inline __inline
- * and we want to get the string "__inline"
- * Suppose we did
- *   STR(inline)
- * that would expand to
- *   #inline
- * which would expand to
- *   "inline"
- * which is not what we want.  If we do
- *  XSTR(inline)
- * that expands to
- *  STR(inline)
- * and then the args are expanded to give
- *  STR(__inline)
- * and then the STR macro is expanded to give
- *  #__inline
- * finally yielding
- *  "__inline"
- * The whole point of this hack is to produce a string for "inline" that will work with the
- * C compiler we are using,as determined by ../configure and stored in ../config.h
- */
-#define STR(S) #S
-#define XSTR(S) STR(S)
-   	    strcat(array, XSTR(inline) " "); /* Use the system-specific inline from config.h  */
-          #else
-            strcat(array, "inline ");
-          #endif
-     }
-     if (tq & T_CONST)
-	  strcat(array, "const ");
-     if (tq & T_VOLATILE)
-	  strcat(array, "volatile ");
-     if (tq & T_RESTRICT)
-	  strcat(array, "__restrict ");
-     if (tq & T_COMPLEX)
-	  strcat(array, "__complex__ ");
-     if (tq & T_NOOUTPUT) {
-	  strcat(array, "__nooutput__ ");
-     }
-     if (tq & T_CILKONLY) {
-	  strcat(array, "__cilkonly__ ");
-     }
-     if (tq & T_CILKSAFE) {
-	  strcat(array, "__cilksafe__ ");
-     }
-     if (tq & T_SUE_ELABORATED)
-	  strcat(array, "sue_elaborated ");
-     if (tq & T_PROCEDURE)
-	  strcat(array, "cilk ");
-     if (tq & T_INLET)
-	  strcat(array, "inlet ");
-
-     return strlen(array);
-}
-
-GLOBAL int PrintTQ(FILE *out, TypeQual tq)
-{
-     char tmp[256];
-
-     TQtoText(tmp, tq);
-     fputs(tmp, out);
-     return strlen(tmp);
+GLOBAL void PrintTQ(GBUF *out, TypeQual tq, int offset, UNUSED(Bool norecurse))
+/* PrintTQ is used only to produce diagnostics.  Hence there is no need for a full OutputContext. */
+{
+    TQtoGBUF(out, tq);
+    if (tq.attributes) PrintList(out, tq.attributes, offset);
 }
 
 GLOBAL TypeQual MergeTypeQuals(TypeQual left, TypeQual right, Coord coord)
 {
      TypeQual scl, scr, dql, dqr, tql, tqr;
-     TypeQual result = 0;
+     TypeQual result = tq_attribute(JoinLists(left.attributes,right.attributes));
 
-     scl = STORAGE_CLASS(left);
-     scr = STORAGE_CLASS(right);
+     scl = tq_storage_class(left);
+     scr = tq_storage_class(right);
 
-     if (scl != 0 && scr != 0) {
-	  if (scl == scr) {	/* scl == scr == single storage class */
+     if (tq_has_anything(scl) && tq_has_anything(scr)) {
+	  if (tq_equal(scl, scr)) {	/* scl == scr == single storage class */
 	       char name[20];
-	       TQtoText(name, scl);
+	       TQtoText(name, 20, scl);
 	       name[strlen(name) - 1] = 0;
 	       WarningCoord(4, coord, "redundant storage class `%s'", name);
 	  } else {
 	       char namel[20], namer[20];
-	       TQtoText(namel, scl);
+	       TQtoText(namel, 20, scl);
 	       namel[strlen(namel) - 1] = 0;
-	       TQtoText(namer, scr);
+	       TQtoText(namer, 20, scr);
 	       namer[strlen(namer) - 1] = 0;
 	       SyntaxErrorCoord(coord, "conflicting storage classes `%s' and `%s'",
 				namel, namer);
 	  }
-	  result |= scl;
+	  result = tq_union(result, scl);
      } else {
-	  result |= scl | scr;
+	  result = tq_union(result, tq_union(scl, scr));
      }
 
-     dql = DECL_QUALS(left) & ~scl;
-     dqr = DECL_QUALS(right) & ~scr;
+     dql = tq_subtract(tq_decl_quals(left), scl);
+     dqr = tq_subtract(tq_decl_quals(right), scr);
 
-     if ((dql & dqr) != 0) {
+     if (tq_has_anything(tq_intersection(dql, dqr))) {
 	  char name[20];
-	  TQtoText(name, dql & dqr);
+	  TQtoText(name, 20, tq_intersection(dql, dqr));
 	  name[strlen(name) - 1] = 0;
 	  WarningCoord(4, coord, "redundant declaration qualifier `%s'", name);
      }
-     result |= (dql | dqr);
+     result = tq_union(result, tq_union(dql, dqr));
 
-     tql = TYPE_QUALS(left);
-     tqr = TYPE_QUALS(right);
+     tql = tq_type_quals(left);
+     tqr = tq_type_quals(right);
 
-     if ((tql & tqr) != 0) {
+     if (tq_has_anything(tq_intersection(tql, tqr))) {
 	  char name[20];
-	  TQtoText(name, tql & tqr);
+	  TQtoText(name, 20, tq_intersection(tql, tqr));
 	  name[strlen(name) - 1] = 0;
 	  WarningCoord(4, coord, "redundant type qualifier `%s'", name);
      }
-     result |= (tql | tqr);
+     result = tq_union(result, tq_union(tql, tqr));
+
      return (result);
 }
 
 /* The tq_coord is passed in and the resulting coord is the min of the original coord and the new coord.
  * That is because in the process of parsing, you can actually have a terminal X that appears after terminal Y and
  * yet terminal X's coordinate is before terminal Y's coord, and we end up with nonidempotent parsing.
- * How can this happen?  Line directives can make it happne.
+ * How can this happen?  Line directives can make it happen.
  */
 GLOBAL Node *TypeQualifyNode(Node *node, TypeQual tq, Coord *tq_coord)
 {
@@ -339,13 +227,13 @@
 	      node->u.fdcl.tq = MergeTypeQuals(node->u.fdcl.tq, tq, node->coord);
 	      break;
 	 default:
-	      PrintNode(stdout, node, 0);
+	      fPrintNode(stdout, node, 0);
 	      printf("\n");
 
 	      /* this assertion always fails */
 	      FAIL("Unexpected node type");
      }
-     minf_coord(&node->coord, tq_coord);
+     if (tq_coord) minf_coord(&node->coord, tq_coord);
      return (node);
 }
 
@@ -380,69 +268,92 @@
 	      return node->u.fdcl.tq;
 	 default:
 	      fprintf(stderr, "Internal Error! Unrecognized type\n");
-	      PrintNode(stderr, node, 0);
+	      fPrintNode(stderr, node, 0);
 	      fprintf(stderr, "\n");
 	      assert(FALSE);
      }
      return (EMPTY_TQ);		/* unreachable */
 }
 
-GLOBAL void NodeSetTq(Node *node, TypeQual mask, TypeQual tq)
-{
-     switch (node->typ) {
-	 case Prim:
-	      node->u.prim.tq &= ~mask;
-	      node->u.prim.tq |= tq;
-	      break;
-	 case Tdef:
-	      node->u.tdef.tq &= ~mask;
-	      node->u.tdef.tq |= tq;
-	      break;
-	 case Ptr:
-	      node->u.ptr.tq &= ~mask;
-	      node->u.ptr.tq |= tq;
-	      break;
-	 case Adcl:
-	      node->u.adcl.tq &= ~mask;
-	      node->u.adcl.tq |= tq;
-	      break;
-	 case Sdcl:
-	      node->u.sdcl.tq &= ~mask;
-	      node->u.sdcl.tq |= tq;
-	      break;
-	 case Udcl:
-	      node->u.udcl.tq &= ~mask;
-	      node->u.udcl.tq |= tq;
-	      break;
-	 case Edcl:
-	      node->u.edcl.tq &= ~mask;
-	      node->u.edcl.tq |= tq;
-	      break;
-	 case Decl:
-	      node->u.decl.tq &= ~mask;
-	      node->u.decl.tq |= tq;
-	      break;
-	 case Fdcl:
-	      node->u.fdcl.tq &= ~mask;
-	      node->u.fdcl.tq |= tq;
-	      break;
-	 default:
-	      fprintf(stderr, "Internal Error! Unrecognized type\n");
-	      PrintNode(stderr, node, 0);
-	      fprintf(stderr, "\n");
-	      assert(FALSE);
-     }
-}
-
-GLOBAL void NodeAddTq(Node *node, TypeQual tq)
-{
-     NodeSetTq(node, 0, tq);
-}
-
-GLOBAL void NodeRemoveTq(Node *node, TypeQual tq)
+#define UPDATEF(field) field = f(field)
+GLOBAL void NodeUpdateTq(Node *node, TypeQual(*f)(TypeQual))
 {
-     NodeSetTq(node, tq, 0);
+    switch (node->typ) {
+    case Prim:
+	UPDATEF(node->u.prim.tq);
+	break;
+    case Tdef:
+	UPDATEF(node->u.tdef.tq);
+	break;
+    case Ptr:
+	UPDATEF(node->u.ptr.tq);
+	break;
+    case Adcl:
+	UPDATEF(node->u.adcl.tq);
+	break;
+    case Sdcl:
+	UPDATEF(node->u.sdcl.tq);
+	break;
+    case Udcl:
+	UPDATEF(node->u.udcl.tq);
+	break;
+    case Edcl:
+	UPDATEF(node->u.edcl.tq);
+	break;
+    case Decl:
+	UPDATEF(node->u.decl.tq);
+	break;
+    case Fdcl:
+	UPDATEF(node->u.fdcl.tq);
+	break;
+    default:
+	fprintf(stderr, "Internal Error! Unrecognized type\n");
+	fPrintNode(stderr, node, 0);
+	fprintf(stderr, "\n");
+	assert(FALSE);
+    }
+}
+#undef UPDATEF
+
+#define UPDATEF(field) field = f(field, tq2)
+GLOBAL void NodeUpdateTq2(Node *node, TypeQual(*f)(TypeQual, TypeQual), TypeQual tq2)
+{
+    switch (node->typ) {
+    case Prim:
+	UPDATEF(node->u.prim.tq);
+	break;
+    case Tdef:
+	UPDATEF(node->u.tdef.tq);
+	break;
+    case Ptr:
+	UPDATEF(node->u.ptr.tq);
+	break;
+    case Adcl:
+	UPDATEF(node->u.adcl.tq);
+	break;
+    case Sdcl:
+	UPDATEF(node->u.sdcl.tq);
+	break;
+    case Udcl:
+	UPDATEF(node->u.udcl.tq);
+	break;
+    case Edcl:
+	UPDATEF(node->u.edcl.tq);
+	break;
+    case Decl:
+	UPDATEF(node->u.decl.tq);
+	break;
+    case Fdcl:
+	UPDATEF(node->u.fdcl.tq);
+	break;
+    default:
+	fprintf(stderr, "Internal Error! Unrecognized type\n");
+	fPrintNode(stderr, node, 0);
+	fprintf(stderr, "\n");
+	assert(FALSE);
+    }
 }
+#undef UPDATEF
 
 /* 
  * NodeTypeQuals, NodeStorageClass, and NodeDeclQuals only work
@@ -451,37 +362,42 @@
  */
 GLOBAL TypeQual NodeTypeQuals(Node *node)
 {
-     return TYPE_QUALS(NodeTq(node));
+     return tq_type_quals(NodeTq(node));
 }
 
 GLOBAL TypeQual NodeStorageClass(Node *node)
 {
-     assert(node->typ == Decl);
-     assert(IsDecl(node));
-     return STORAGE_CLASS(node->u.decl.tq);
+     return tq_storage_class(NodeDeclTq(node));
 }
 
 GLOBAL void NodeSetStorageClass(Node *node, TypeQual sc)
 {
-     NodeSetTq(node, T_STORAGE_CLASSES, sc);
+    NodeUpdateTq2(node, tq_set_storage_class_from, sc);
+}
+
+GLOBAL TypeQual NodeDeclTq (Node *node) {
+    assert(node->typ==Decl);
+    assert(IsDecl(node));
+    return node->u.decl.tq;
 }
 
+/*
 GLOBAL TypeQual NodeDeclQuals(Node *node)
 {
-     assert(node->typ == Decl);
-     return DECL_QUALS(node->u.decl.tq);
+     return DECL_QUALS(NodeDeclTq(node));
 }
+*/
 
 GLOBAL TypeQual NodeDeclLocation(Node *node)
 {
      assert(node->typ == Decl);
      assert(IsDecl(node));
-     return DECL_LOCATION(node->u.decl.tq);
+     return tq_decl_location(node->u.decl.tq);
 }
 
 GLOBAL void NodeSetDeclLocation(Node *node, TypeQual dl)
 {
-     NodeSetTq(node, T_DECL_LOCATIONS, dl);
+    NodeUpdateTq2(node, tq_set_decl_location_from, dl);
 }
 
 /*************************************************************************/
@@ -507,7 +423,7 @@
      /* note: memory leak of *n2 */
 
      assert(node != NULL && node->typ == Prim);
-     assert(node != NULL && n2->typ == Prim);
+     assert(n2   != NULL && n2->typ == Prim);
 
      BASIC2EXPLODED(node->u.prim.basic, et1);
      BASIC2EXPLODED(n2->u.prim.basic, et2);
@@ -715,6 +631,11 @@
      return FinishPrimType(create);
 }
 
+GLOBAL const char *TypeName(TypeSpecifier ts) {
+    assert(ts<MaxBasicType); // ts is an unsigned value
+    return TypeNames[ts];
+}
+
 PRIVATE const char *TypeSpecifierName(TypeSpecifier ts)
 {
      if ((ts & BasicTypeMask) != 0)
@@ -781,40 +702,13 @@
 	      return type;
      }
 
-     if ((tq = NodeTq(type)) != EMPTY_TQ) {
+     if (tq_has_anything(tq = NodeTq(type))) {
 	  new = NodeCopy(new, NodeOnly);
-	  NodeAddTq(new, tq);
+	  NodeUpdateTq2(new, tq_union, tq);
      }
      return new;
 }
 
-GLOBAL void PrimToText(char array[], Node *type)
-{
-     char *ptr = array;
-     int len;
-
-     assert(type);
-     assert(type->typ == Prim);
-
-     len = TQtoText(ptr, type->u.prim.tq & (unsigned int)~T_SUE_ELABORATED); /* Don't print sue_elaborated */
-     ptr += len;
-
-     strcpy(ptr, TypeNames[type->u.prim.basic]);
-}
-
-GLOBAL int PrintPrimType(FILE *out, Node *type, char *lastc)
-{
-     char tmp[256];
-     int len;
-
-     PrimToText(tmp, type);
-     fputs(tmp, out);
-     len = strlen(tmp);
-     if (len>0 && lastc)
-	 *lastc = tmp[len-1];
-     return len;
-}
-
 /*************************************************************************/
 /*                                                                       */
 /*         Resolving identifiers through the symbol table                */
@@ -836,7 +730,7 @@
 	  REFERENCE(var);
 	  if (TrackIds) {
 	       fprintf(stderr, "=== `%s' = ", name);
-	       PrintNode(stderr, var, 0);
+	       fPrintNode(stderr, var, 0);
 	       printf("\n");
 	  }
      }
@@ -874,7 +768,7 @@
 			    id->u.id.text);
 
 	       var = MakeDeclCoord(id->u.id.text,
-				   T_TOP_DECL,
+				   TQ_TOP_DECL,
 				   MakeFdclCoord(EMPTY_TQ, NULL, MakeDefaultPrimType(EMPTY_TQ, id->coord),
 						 id->coord),
 				   NULL,
@@ -894,7 +788,7 @@
 	  REFERENCE(var);
 	  if (TrackIds) {
 	       fprintf(stderr, "=== `%s' = ", id->u.id.text);
-	       PrintNode(stderr, var, 0);
+	       fPrintNode(stderr, var, 0);
 	  }
      }
      return (call);
@@ -937,7 +831,7 @@
 	      Warning(1, "Internal Error!");
 	      fprintf(stderr, "\tLookupPostfixExpression: unexpected node:\n");
 	      PrintASTcoords=TRUE;
-	      PrintNode(stderr, post, 2);
+	      fPrintNode(stderr, post, 2);
 	      FAIL("Unexpected node type");
      }
      return (post);
@@ -963,9 +857,9 @@
 
      if (var->u.decl.references == 0 && type->typ != Fdcl) {
 	  /* give warning only if unused local variable */
-	  if (NodeDeclLocation(var) == T_BLOCK_DECL &&
-	      NodeStorageClass(var) != T_EXTERN)
-	       WarningCoord(2, var->coord, "unused variable `%s'", VAR_NAME(var));
+	 if (tq_has_block_decl(NodeDeclLocation(var)) &&
+	     !tq_has_extern(NodeStorageClass(var)))
+	     WarningCoord(2, var->coord, "unused variable `%s'", VAR_NAME(var));
      }
 }
 
@@ -1021,7 +915,7 @@
 		       WarningCoord(1, node->coord,
 			  "NodeSizeof(): Unrecognized primitive type %d",
 				    type->u.prim.basic);
-		       PrintNode(stderr, node, 0);
+		       fPrintNode(stderr, node, 0);
 		       fputc('\n', stderr);
 		       return 1;
 	      }
@@ -1072,7 +966,7 @@
 	      WarningCoord(1, node->coord,
 			   "NodeSizeof(): Unrecognized node type %d",
 			   type->typ);
-	      PrintNode(stderr, node, 0);
+	      fPrintNode(stderr, node, 0);
 	      fputc('\n', stderr);
 	      return 1;
      default:
@@ -1160,32 +1054,34 @@
 
 GLOBAL Bool DeclIsExtern(Node *node)
 {
-     return (NodeStorageClass(node) == T_EXTERN);
+     assert(node->typ == Decl);
+     return tq_has_extern(node->u.decl.tq);
 }
 
 GLOBAL Bool NodeIsConstQual(Node *node)
 {
-     return (NodeTypeQuals(node) & T_CONST) != 0;
+    return tq_has_const(NodeTq(node));
 }
 
 GLOBAL Bool NodeIsCilkProcedure(Node *node)
 {
-     return (NodeTypeQuals(node) & T_PROCEDURE) != 0;
+    return tq_has_procedure(NodeTq(node));
 }
 
 GLOBAL Bool DeclIsEnumConst(Node *node)
 {
-     return NodeDeclLocation(node) == T_ENUM_DECL;
+     assert(node->typ == Decl);
+     return tq_has_enum_decl(node->u.decl.tq);
 }
 
 GLOBAL Bool DeclIsTypedef(Node *node)
 {
-     return (NodeStorageClass(node) == T_TYPEDEF);
+     return tq_has_typedef(NodeStorageClass(node));
 }
 
 GLOBAL Bool DeclIsStatic(Node *node)
 {
-     return (NodeStorageClass(node) == T_STATIC);
+     return tq_has_static(NodeStorageClass(node));
 }
 
 GLOBAL Bool DeclIsExternal(Node *node)
@@ -1193,12 +1089,12 @@
      TypeQual sc = NodeStorageClass(node);
      TypeQual dl = NodeDeclLocation(node);
 
-     return sc == T_EXTERN || dl == T_TOP_DECL;
+     return tq_has_extern(sc) || tq_has_top_decl(dl);
 }
 
 GLOBAL Bool DeclIsBlock(Node *node)
 {
-     return (NodeDeclLocation(node) == T_BLOCK_DECL);
+    return tq_has_block_decl(NodeDeclLocation(node));
 }
 
 GLOBAL Node *PtrSubtype(Node *ptr)
@@ -1387,7 +1283,7 @@
      UnwindTdefs(&type, &tq);
 
      /* test first for modifiability, if required by caller */
-     if (modifiablep && (tq & T_CONST) != 0)
+     if (modifiablep && tq_has_const(tq))
 	  return FALSE;
 
      /* now test whether node is an lvalue */
@@ -1404,7 +1300,7 @@
 		       return TRUE;
 		  case Adcl:
 		  case Fdcl:
-		       if (NodeDeclLocation(node->u.id.decl) == T_FORMAL_DECL)
+		      if (tq_has_formal_decl(NodeDeclLocation(node->u.id.decl)))
 			    /* formals of type array or function are treated as pointers to same,
 			     * thus lvalues */
 			    return TRUE;
@@ -1792,7 +1688,7 @@
      *ptq = NodeTypeQuals(*pnode);
      while ((*pnode)->typ == Tdef) {
 	  *pnode = (*pnode)->u.tdef.type;
-	  *ptq |= NodeTypeQuals(*pnode);
+	  *ptq = tq_union(*ptq, NodeTypeQuals(*pnode));
      }
 }
 
@@ -1824,13 +1720,13 @@
      UnwindTdefs(&node1, &tq1);
      UnwindTdefs(&node2, &tq2);
 
-     tq1 &= ~T_SUE_ELABORATED;
-     tq2 &= ~T_SUE_ELABORATED;
+     tq1 = tq_remove_sue_elaborated(tq1);
+     tq2 = tq_remove_sue_elaborated(tq2);
      if (!strict_toplevel) {
-	  tq1 &= ~TQ_COMPATIBLE;
-	  tq2 &= ~TQ_COMPATIBLE;
+	  tq1 = tq_remove_compatible(tq1);
+	  tq2 = tq_remove_compatible(tq2);
      }
-     if (tq1 != tq2)
+     if (!tq_equal(tq1, tq2))
 	  return FALSE;
 
      if (node1->typ != node2->typ)
@@ -1930,5 +1826,3 @@
      }
      return FALSE;		/* eliminates warning */
 }
-
-
diff -Nur 5.4.2.2/cilk2c/type.h current.Bug188/cilk2c/type.h
--- 5.4.2.2/cilk2c/type.h	2004-10-23 03:26:42.000000000 +0000
+++ current.Bug188/cilk2c/type.h	2005-10-22 02:52:38.000000000 +0000
@@ -31,7 +31,7 @@
 #ifndef _TYPE_H_
 #define _TYPE_H_
 FILE_IDENTITY(type_ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/type.h $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/type.h $ $LastChangedBy: bradley $ $Rev: 2484 $ $Date$");
 
 GLOBAL extern Node *EllipsisNode;	/* represents '...'  primitive type */
 
@@ -91,25 +91,27 @@
 GLOBAL TypeQual MergeTypeQuals(TypeQual left, TypeQual right, Coord coord);
 GLOBAL Node *MakeMergedType(Node *type1, Node *qual1);
 GLOBAL TypeQual NodeTq(Node *node);
-GLOBAL void NodeSetTq(Node *node, TypeQual mask, TypeQual tq);
-GLOBAL void NodeAddTq(Node *node, TypeQual tq);
-GLOBAL void NodeRemoveTq(Node *node, TypeQual tq);
+GLOBAL void NodeUpdateTq(Node *node, TypeQual(*f)(TypeQual));
+GLOBAL void NodeUpdateTq2(Node *node, TypeQual(*f)(TypeQual, TypeQual), TypeQual tq2);
 GLOBAL TypeQual NodeTypeQuals(Node *node);
-GLOBAL TypeQual NodeDeclQuals(Node *node);
+GLOBAL TypeQual NodeDeclTq (Node *node); /* Return all the typequals on a decl (error if it is not a decl) */
+/*GLOBAL TypeQual NodeDeclQuals(Node *node);*/
 GLOBAL TypeQual NodeStorageClass(Node *node);
 GLOBAL void NodeSetStorageClass(Node *node, TypeQual sc);
 GLOBAL TypeQual NodeDeclLocation(Node *node);
 GLOBAL void NodeSetDeclLocation(Node *node, TypeQual dl);
-GLOBAL int TQtoText(char array[], TypeQual tq);
-GLOBAL int PrintTQ(FILE *out, TypeQual tq);
+GLOBAL void TQtoText(char array[], int arraysize, TypeQual tq); /* TQtoText is only used to produce error messages.  Hence no need for a full OutputContext. */
+GLOBAL void PrintTQ(GBUF *out, TypeQual tq, int offset, Bool norecurse); /* PrintTQ is only used to produce diagnostics, and we don't really need a full OutputContext */
 
 GLOBAL Node *StartPrimType(BasicType basic, Coord coord);
 GLOBAL Node *MergePrimTypes(Node *node, Node *node2);
 GLOBAL Node *FinishPrimType(Node *PrimNode);
 GLOBAL Node *MakeDefaultPrimType(TypeQual tq, Coord coord);
 GLOBAL Node *SansSign(Node *type);
-GLOBAL void PrimToText(char array[], Node *type);
-GLOBAL int PrintPrimType(FILE *out, Node *type, char *lastc);  /* return the number of characters printed, and if any are printed and lastc!=NULL, set *lastc to the last character sent. */
+
+/* return the number of characters printed, and if any are printed and lastc!=NULL, set *lastc to the last character sent. */
+GLOBAL int PrintPrimType(GBUF *gb, Node *type, char *lastc);
+
 
 GLOBAL Node *LookupFunction(Node *call);
 GLOBAL Node *LookupPostfixExpression(Node *post);
@@ -214,7 +216,7 @@
 
 /* Global procedures from sue.c */
 
-GLOBAL void PrintSUE(FILE *out, SUEtype *sue, int offset, Bool norecurse);
+GLOBAL void PrintSUE(GBUF *out, SUEtype *sue, int offset, Bool norecurse);
 GLOBAL Node *SetSUdclNameFields(Node *sudcl, Node *id, List *fields, Coord left_coord, Coord right_coord, List *attributes);
 GLOBAL Node *SetSUdclName(Node *sudcl, Node *id, Coord coord);
 GLOBAL Node *BuildEnum(Node *id, List *values, Coord enum_coord, Coord left_coord, Coord right_coord);
@@ -248,6 +250,7 @@
 GLOBAL Node *NodeDataTypeSuperior(Node *node);
 GLOBAL void SetNodeDataType(Node *node, Node *type);
 GLOBAL Node *SdclFindField(Node *sdcl, Node *field_name);
+GLOBAL const char*TypeName(TypeSpecifier);
 
 /* From operators.c */
 GLOBAL const char *OperatorName(OpType op);
diff -Nur 5.4.2.2/cilk2c/type2.c current.Bug188/cilk2c/type2.c
--- 5.4.2.2/cilk2c/type2.c	2004-10-23 03:26:19.000000000 +0000
+++ current.Bug188/cilk2c/type2.c	2005-10-22 02:52:37.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/type2.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/type2.c $ $LastChangedBy: bradley $ $Rev: 2483 $ $Date$");
 
 
 PRIVATE Node *NodeDataTypeBase(Node *node, Bool TdefIndir);
@@ -55,7 +55,7 @@
 
      if (result == NULL) {
 	  printf("NodeDataType().  Trying to return NULL\n");
-	  PrintNode(stdout, node, 0);
+	  fPrintNode(stdout, node, 0);
 	  printf("\n");
 	  assert(FALSE);
      }
@@ -72,7 +72,7 @@
 
      if (result == NULL) {
 	  printf("NodeDataTypeSuperior().  Trying to return NULL\n");
-	  PrintNode(stdout, node, 0);
+	  fPrintNode(stdout, node, 0);
 	  printf("\n");
 	  assert(FALSE);
      }
@@ -207,7 +207,7 @@
 
 	 default:
 	      fprintf(stderr, "Internal Error! NodeDataType: Unknown node type\n");
-	      PrintNode(stderr, node, 0);
+	      fPrintNode(stderr, node, 0);
 	      fprintf(stderr, "\n");
 	      return node;
      }
@@ -279,7 +279,7 @@
 	  fprintf(stderr, "ArrayType: Node at ");
 	  PRINT_COORD(stderr, array->coord);
 	  fputc('\n', stderr);
-	  PrintNode(stderr, array, 0);
+	  fPrintNode(stderr, array, 0);
 	  fprintf(stderr, "\n");
 	  assert(FALSE);
 	  return (NULL);
@@ -300,16 +300,16 @@
 	       return (SdclFindField(sdcl->u.binop.type, field_name));
 	  else {
 	       printf("SdclFindField(): not a supported binop\n");
-	       PrintNode(stdout, sdcl, 0);
+	       fPrintNode(stdout, sdcl, 0);
 	       printf("\n");
-	       PrintNode(stdout, field_name, 0);
+	       fPrintNode(stdout, field_name, 0);
 	       printf("\n");
 	       assert(FALSE);
      } else {
 	  printf("SdclFindField(): not a recognized type\n");
-	  PrintNode(stdout, sdcl, 0);
+	  fPrintNode(stdout, sdcl, 0);
 	  printf("\n");
-	  PrintNode(stdout, field_name, 0);
+	  fPrintNode(stdout, field_name, 0);
 	  printf("\n");
 	  assert(FALSE);
      }
diff -Nur 5.4.2.2/cilk2c/typequal.c current.Bug188/cilk2c/typequal.c
--- 5.4.2.2/cilk2c/typequal.c	1970-01-01 00:00:00.000000000 +0000
+++ current.Bug188/cilk2c/typequal.c	2005-10-22 02:54:14.000000000 +0000
@@ -0,0 +1,285 @@
+#include "ast.h"
+
+typedef enum {
+
+     EMPTY_TQ_enum = 0,
+/* 
+   Declaration qualifiers.  A declaration can have multiple qualifiers,
+   though some are mutually exclusive (like storage classes).
+   During the parsing of a declaration, decl qualifiers are kept in 
+   the tq field of its primitive type.  After the decl has been parsed,
+   SetDeclType then moves the qualifiers to their proper place, the 
+   Decl node.
+
+   To add a new decl qualifier:
+      1. Define a new symbol below, being careful that its bits do
+         not conflict with existing decl and type qualifiers,
+         since they can coexist in the same TypeQual variable.
+      2. Insert the symbol in T_DECL_QUALS (below).
+      3. If the qualifier is parsed in the source (rather than calculated),
+         add a lexical token (c4.l) and a new production to storage.classes
+         (ANSI-C.y).
+      4. Add code to print out its name in TQtoText (type.c).
+      5. Add merging logic to MergeTypeQuals (type.c), if necessary.
+*/
+
+  T_AUTO     = 0x00001,
+  T_EXTERN   = 0x00002,
+  T_REGISTER = 0x00003,
+  T_STATIC   = 0x00004,
+  T_TYPEDEF  = 0x00005,
+  /* Insert new storage classes here */
+
+  T_STORAGE_CLASSES = (T_AUTO | T_EXTERN | T_REGISTER | T_STATIC | T_TYPEDEF),
+#define STORAGE_CLASS(tq) ((tq) & T_STORAGE_CLASSES)
+
+  /* the following qualifiers are all mutually exclusive,
+     so they can share bits */
+  T_TOP_DECL    = 0x00010,   /* top-level decl */
+  T_BLOCK_DECL  = 0x00020,   /* local decl in a block */
+  T_FORMAL_DECL = 0x00030,   /* formal parameter decl */
+  T_SU_DECL     = 0x00040,   /* struct/union field decl */
+  T_ENUM_DECL   = 0x00050,   /* enumerated constant decl */
+  /* Insert new decl locations here */
+  
+  T_DECL_LOCATIONS = (T_TOP_DECL | T_BLOCK_DECL | T_FORMAL_DECL |
+		      T_SU_DECL | T_ENUM_DECL),
+#define DECL_LOCATION(tq)  ((tq) & T_DECL_LOCATIONS)
+
+     /* Flag for redundant external declaration, which is defined as
+      * an external declaration (NOT a definition, so it must have no
+      * initializer or function body) of a name previously declared external 
+      * in the same scope.  A trivial example:
+      *    extern int x;
+      *    extern int x;    <-- redundant
+      * But:
+      *    { extern int x; }
+      *    { extern int x; }  <-- not redundant
+      * because the two declarations have different scopes.
+      */
+     T_REDUNDANT_EXTERNAL_DECL = 0x00100,
+
+     /* Insert new decl qualifiers here */
+     T_SHARED           =   0x00200,
+     T_PRIVATE          =   0x00400,
+     T_NOOUTPUT         =   0x00800,	
+     T_CILKONLY         =   0x01000,	/* variable can only be used in cilk code */
+     T_CILKSAFE         =   0x02000,	/* promise that this variable is safe to access in parallel */
+
+     /* the following tq's are used to generate CILK_WHERE_AM_I directives */
+     T_FAST_PROCEDURE   =  0x04000,
+     T_SLOW_PROCEDURE   =  0x08000,
+     T_FAST_INLET       =  0x10000,
+     T_SLOW_INLET       =  0x20000,
+     T_STANDALONE_INLET =  0x40000,
+     T_C_CODE           =  0x80000,
+
+     T_CILK_WHERE_AM_I_DECL_QUALS  = (T_FAST_PROCEDURE | T_SLOW_PROCEDURE | T_FAST_INLET | T_SLOW_INLET | T_STANDALONE_INLET | T_C_CODE),
+
+     T_DECL_QUALS = (T_STORAGE_CLASSES | T_DECL_LOCATIONS 
+		     | T_REDUNDANT_EXTERNAL_DECL 
+		     | T_SHARED | T_PRIVATE | T_NOOUTPUT 
+		     | T_CILKONLY | T_CILKSAFE
+		     | T_CILK_WHERE_AM_I_DECL_QUALS
+		     ),
+
+#define DECL_QUALS(tq)    ((tq) & T_DECL_QUALS)
+
+
+/*
+   Type qualifiers.  Multiple type qualifiers may apply to a type.  
+   They may be associated with any primitive or complex type.  
+   Some type qualifiers may be moved after parsing -- for instance,
+   T_INLINE is moved to the top-level Fdcl it is describing.
+
+   To add a new type qualifier:
+      1. Define a new symbol below, being careful that its bits do
+         not conflict with existing storage classes and type qualifiers,
+         since they can coexist in the same TypeQual variable.
+      2. Insert the symbol in T_TYPE_QUALS (below).
+      3. Add a lexical token (c4.l) and a new production to either
+         type.qualifiers or pointer.type.qualifiers (ANSI-C.y), depending 
+         on whether the type qualifier is allowed only at the beginning
+         of a type, or can appear after '*' like const and volatile.
+      4. Add code to print out its name in TQtoText (type.c).
+      5. Add its symbol to TQ_ALWAYS_COMPATIBLE (below) if an object with
+         the type qualifier is always assignment-compatible with an object
+	 without the type qualifier.
+      6. Add merging logic to MergeTypeQuals (type.c), if necessary.
+ */
+
+    T_RESTRICT = 0x100000,
+    T_COMPLEX  = 0x200000,
+
+    T_CONST    = 0x400000,   /* leave some room for new decl qualifiers */
+    T_VOLATILE = 0x800000,
+    T_INLINE   = 0x1000000,
+    T_SUE_ELABORATED  = 0x2000000,   /* on an Sdcl/Udcl/Edcl, indicates 
+				      whether SUE's field list appeared
+				      at that point in the source */
+#define SUE_ELABORATED(tq)   (((tq) & T_SUE_ELABORATED) != 0)
+    /* Insert new type qualifiers here */
+    T_PROCEDURE       = 0x4000000,
+
+    T_INLET           = 0x8000000,
+
+    T_EXTENSION       = 0x10000000, /* used for gcc __extension__ keyword.  Not exactly a TYPE_QUAL */
+
+    T_TYPE_QUALS = (T_RESTRICT | T_COMPLEX | T_CONST | T_VOLATILE | T_INLINE | T_SUE_ELABORATED | T_PROCEDURE | T_INLET ),
+#define TYPE_QUALS(tq)    ((tq) & T_TYPE_QUALS)
+    
+/* Type qualifiers listed in TQ_COMPATIBLE are ignored
+ * when checking two types for compatibility (weaker than strict equality). */
+    TQ_COMPATIBLE   = (T_CONST | T_VOLATILE | T_INLINE | T_SUE_ELABORATED | T_RESTRICT | T_EXTENSION)
+
+}
+ TypeQual_enum;
+
+PRIVATE inline int bit_is_set(TypeQual tq, TypeQual_enum bit) {
+    return (tq.tq&bit)==bit;
+}
+PRIVATE inline TypeQual TQ (TypeQual_enum e) {
+    return (TypeQual){e,0};
+}
+GLOBAL TypeQual tq_attribute (List *attrib) {
+    return (TypeQual){0,attrib};
+}
+PRIVATE inline TypeQual TQsetbit(TypeQual tq, TypeQual_enum bits) {
+    return (TypeQual){tq.tq|bits, tq.attributes};
+}
+PRIVATE inline TypeQual TQclearbit(TypeQual tq, TypeQual_enum bits) {
+    return (TypeQual){tq.tq&~bits, tq.attributes};
+}
+
+GLOBAL int tq_has_auto     (TypeQual tq) { return STORAGE_CLASS(tq.tq)==T_AUTO; }
+GLOBAL int tq_has_extern   (TypeQual tq) { return STORAGE_CLASS(tq.tq)==T_EXTERN; }
+GLOBAL int tq_has_register (TypeQual tq) { return STORAGE_CLASS(tq.tq)==T_REGISTER; }
+GLOBAL int tq_has_static   (TypeQual tq) { return STORAGE_CLASS(tq.tq)==T_STATIC; }
+GLOBAL int tq_has_typedef  (TypeQual tq) { return STORAGE_CLASS(tq.tq)==T_TYPEDEF; }
+GLOBAL int tq_has_some_storageclass (TypeQual tq) { return STORAGE_CLASS(tq.tq)!=0; }
+
+GLOBAL TypeQual tq_add_auto     (TypeQual tq) { return TQsetbit(tq,T_AUTO); }
+GLOBAL TypeQual tq_add_extern   (TypeQual tq) { return TQsetbit(tq,T_EXTERN); }
+GLOBAL TypeQual tq_add_register (TypeQual tq) { return TQsetbit(tq,T_REGISTER); }
+GLOBAL TypeQual tq_add_static   (TypeQual tq) { return TQsetbit(tq,T_STATIC); }
+GLOBAL TypeQual tq_add_typedef  (TypeQual tq) { return TQsetbit(tq,T_TYPEDEF); }
+
+GLOBAL TypeQual tq_storage_class (TypeQual tq) { return TQ(STORAGE_CLASS(tq.tq)); }
+GLOBAL TypeQual tq_remove_all_storage_classes (TypeQual tq) { return TQ(tq.tq&~T_STORAGE_CLASSES); }
+GLOBAL TypeQual tq_set_storage_class_from (TypeQual dest, TypeQual source) { return tq_union(tq_remove_all_storage_classes(dest),tq_storage_class(source)); }
+
+
+GLOBAL int tq_has_top_decl    (TypeQual tq) { return DECL_LOCATION(tq.tq)==T_TOP_DECL; }
+GLOBAL int tq_has_block_decl  (TypeQual tq) { return DECL_LOCATION(tq.tq)==T_BLOCK_DECL; }
+GLOBAL int tq_has_formal_decl (TypeQual tq) { return DECL_LOCATION(tq.tq)==T_FORMAL_DECL; }
+GLOBAL int tq_has_su_decl     (TypeQual tq) { return DECL_LOCATION(tq.tq)==T_SU_DECL; }
+GLOBAL int tq_has_enum_decl   (TypeQual tq) { return DECL_LOCATION(tq.tq)==T_ENUM_DECL; }
+
+/* These are mutually exlusive, so take care to zero out the old data before oring in the new data. */
+GLOBAL TypeQual tq_add_top_decl    (TypeQual tq) { return (TypeQual){(tq.tq&~T_DECL_LOCATIONS)|T_TOP_DECL, tq.attributes}; }
+GLOBAL TypeQual tq_add_block_decl  (TypeQual tq) { return (TypeQual){(tq.tq&~T_DECL_LOCATIONS)|T_BLOCK_DECL, tq.attributes}; }
+GLOBAL TypeQual tq_add_formal_decl (TypeQual tq) { return (TypeQual){(tq.tq&~T_DECL_LOCATIONS)|T_FORMAL_DECL, tq.attributes}; }
+GLOBAL TypeQual tq_add_su_decl     (TypeQual tq) { return (TypeQual){(tq.tq&~T_DECL_LOCATIONS)|T_SU_DECL, tq.attributes}; }
+GLOBAL TypeQual tq_add_enum_decl   (TypeQual tq) { return (TypeQual){(tq.tq&~T_DECL_LOCATIONS)|T_ENUM_DECL, tq.attributes}; }
+
+GLOBAL TypeQual tq_decl_location (TypeQual tq) { return TQ(DECL_LOCATION(tq.tq)); }
+GLOBAL TypeQual tq_set_decl_location_from (TypeQual tq, TypeQual source) { return (TypeQual){(tq.tq&~T_DECL_LOCATIONS)|DECL_LOCATION(source.tq), tq.attributes}; }
+
+GLOBAL int tq_has_redundant_external_decl (TypeQual tq) { return bit_is_set(tq,T_REDUNDANT_EXTERNAL_DECL); }
+GLOBAL TypeQual tq_add_redundant_external_decl(TypeQual tq) { return TQsetbit(tq,T_REDUNDANT_EXTERNAL_DECL); }
+GLOBAL TypeQual tq_remove_redundant_external_decl(TypeQual tq) { return TQclearbit(tq, T_REDUNDANT_EXTERNAL_DECL); }
+
+
+GLOBAL int tq_has_shared (TypeQual tq)   { return bit_is_set(tq,T_SHARED); }
+GLOBAL int tq_has_private (TypeQual tq)  { return bit_is_set(tq,T_PRIVATE); }
+GLOBAL int tq_has_nooutput (TypeQual tq) { return bit_is_set(tq,T_NOOUTPUT); }
+GLOBAL int tq_has_cilkonly (TypeQual tq) { return bit_is_set(tq,T_CILKONLY); }
+GLOBAL int tq_has_cilksafe (TypeQual tq) { return bit_is_set(tq,T_CILKSAFE); }
+
+GLOBAL TypeQual tq_add_shared (TypeQual tq)   { return TQsetbit(tq,T_SHARED); }
+GLOBAL TypeQual tq_add_private (TypeQual tq)  { return TQsetbit(tq,T_PRIVATE); }
+GLOBAL TypeQual tq_add_nooutput (TypeQual tq) { return TQsetbit(tq,T_NOOUTPUT); }
+GLOBAL TypeQual tq_add_cilkonly (TypeQual tq) { return TQsetbit(tq,T_CILKONLY); }
+GLOBAL TypeQual tq_add_cilksafe (TypeQual tq) { return TQsetbit(tq,T_CILKSAFE); }
+
+/* Consider decl_quals to include attributes. */
+GLOBAL TypeQual tq_remove_all_decl_quals (TypeQual tq) { return (TypeQual){tq.tq&~T_DECL_QUALS,0}; }
+
+GLOBAL int tq_has_fast_procedure (TypeQual tq)   { return bit_is_set(tq, T_FAST_PROCEDURE); }
+GLOBAL int tq_has_slow_procedure (TypeQual tq)   { return bit_is_set(tq, T_SLOW_PROCEDURE); }
+GLOBAL int tq_has_fast_inlet (TypeQual tq)       { return bit_is_set(tq, T_FAST_INLET); }
+GLOBAL int tq_has_slow_inlet (TypeQual tq)       { return bit_is_set(tq, T_SLOW_INLET); }
+GLOBAL int tq_has_standalone_inlet (TypeQual tq) { return bit_is_set(tq, T_STANDALONE_INLET); }
+GLOBAL int tq_has_c_code (TypeQual tq)           { return bit_is_set(tq, T_C_CODE); }
+
+GLOBAL TypeQual tq_add_fast_procedure (TypeQual tq)   { return TQsetbit(tq,T_FAST_PROCEDURE); }
+GLOBAL TypeQual tq_add_slow_procedure (TypeQual tq)   { return TQsetbit(tq,T_SLOW_PROCEDURE); }
+GLOBAL TypeQual tq_add_fast_inlet (TypeQual tq)       { return TQsetbit(tq,T_FAST_INLET); }
+GLOBAL TypeQual tq_add_slow_inlet (TypeQual tq)       { return TQsetbit(tq,T_SLOW_INLET); }
+GLOBAL TypeQual tq_add_standalone_inlet (TypeQual tq) { return TQsetbit(tq,T_STANDALONE_INLET); }
+GLOBAL TypeQual tq_add_c_code (TypeQual tq)           { return TQsetbit(tq,T_C_CODE); }
+
+GLOBAL int tq_has_cilk_where_am_i_decl_quals(TypeQual tq) {
+    return (tq.tq & T_CILK_WHERE_AM_I_DECL_QUALS )!=0;
+}
+GLOBAL TypeQual tq_remove_cilk_where_am_i_decl_quals(TypeQual tq) {
+    /* Remove the cilk "where-am-i" declaration qualifiers */
+    return TQclearbit(tq, ~T_CILK_WHERE_AM_I_DECL_QUALS );
+}
+
+GLOBAL TypeQual TQ_DECL_QUALS(void) {
+    return TQ(T_DECL_QUALS);
+}
+
+GLOBAL TypeQual tq_decl_quals(TypeQual tq) {
+    return (TypeQual){DECL_QUALS(tq.tq), tq.attributes};
+}
+
+GLOBAL int tq_has_restrict (TypeQual tq)       { return bit_is_set(tq,T_RESTRICT); }
+GLOBAL int tq_has_complex (TypeQual tq)        { return bit_is_set(tq,T_COMPLEX); }
+GLOBAL int tq_has_const (TypeQual tq)          { return bit_is_set(tq,T_CONST); }
+GLOBAL int tq_has_volatile (TypeQual tq)       { return bit_is_set(tq,T_VOLATILE); }
+GLOBAL int tq_has_inline(TypeQual tq)          { return bit_is_set(tq,T_INLINE); }
+GLOBAL int tq_has_sue_elaborated (TypeQual tq) { return bit_is_set(tq,T_SUE_ELABORATED); }
+GLOBAL int tq_has_procedure(TypeQual tq)       { return bit_is_set(tq,T_PROCEDURE); }
+GLOBAL int tq_has_inlet(TypeQual tq)           { return bit_is_set(tq,T_INLET); }
+GLOBAL int tq_has_extension (TypeQual tq)      { return bit_is_set(tq,T_EXTENSION); }
+
+GLOBAL TypeQual tq_add_restrict (TypeQual tq)       { return TQsetbit(tq,T_RESTRICT); }
+GLOBAL TypeQual tq_add_complex (TypeQual tq)        { return TQsetbit(tq,T_COMPLEX); }
+GLOBAL TypeQual tq_add_const (TypeQual tq)          { return TQsetbit(tq,T_CONST); }
+GLOBAL TypeQual tq_add_volatile(TypeQual tq)        { return TQsetbit(tq,T_VOLATILE); }
+GLOBAL TypeQual tq_add_inline (TypeQual tq)         { return TQsetbit(tq,T_INLINE); }
+GLOBAL TypeQual tq_add_sue_elaborated (TypeQual tq) { return TQsetbit(tq,T_SUE_ELABORATED); }
+GLOBAL TypeQual tq_add_procedure (TypeQual tq)      { return TQsetbit(tq,T_PROCEDURE); }
+GLOBAL TypeQual tq_add_inlet (TypeQual tq)          { return TQsetbit(tq,T_INLET); }
+GLOBAL TypeQual tq_add_extension (TypeQual tq)      { return TQsetbit(tq,T_EXTENSION); }
+
+GLOBAL TypeQual tq_remove_complex(TypeQual tq)         { return TQclearbit(tq, T_COMPLEX); }
+GLOBAL TypeQual tq_remove_const (TypeQual tq)          { return TQclearbit(tq, T_CONST); }
+GLOBAL TypeQual tq_remove_inline (TypeQual tq)         { return TQclearbit(tq, T_INLINE); }
+GLOBAL TypeQual tq_remove_sue_elaborated (TypeQual tq) { return TQclearbit(tq, T_SUE_ELABORATED); }
+GLOBAL TypeQual tq_remove_procedure (TypeQual tq)      { return TQclearbit(tq, T_PROCEDURE); }
+GLOBAL TypeQual tq_remove_inlet (TypeQual tq)          { return TQclearbit(tq, T_INLET); }
+
+GLOBAL TypeQual tq_type_quals (TypeQual tq) { return TQ(TYPE_QUALS(tq.tq)); }
+GLOBAL TypeQual tq_remove_compatible (TypeQual tq) { return TQclearbit(tq, TQ_COMPATIBLE); }
+
+PRIVATE List* UnionLists(List *a, List *b) {
+    if (a==NULL) return b;
+    if (b==NULL) return a;
+    if (a==b) return a;
+    if (FindItem(b, FirstItem(a))) return UnionLists (Rest(a), b);
+    return ConsItem(FirstItem(a), UnionLists(Rest(a), b));
+}
+
+GLOBAL TypeQual tq_union (TypeQual a, TypeQual b) { /* Produce a type qualifier which is the union of two others. */
+    return (TypeQual){a.tq|b.tq, UnionLists(a.attributes, b.attributes)};
+}
+GLOBAL TypeQual tq_intersection (TypeQual a, TypeQual b) { return TQ(a.tq&b.tq); }
+GLOBAL TypeQual tq_subtract (TypeQual a, TypeQual b) { return (TypeQual){a.tq & ~b.tq, a.attributes}; }
+
+GLOBAL int tq_has_anything (TypeQual tq) { return tq.tq!=0; }
+GLOBAL TypeQual tq_remove_everything (TypeQual tq __attribute__((__unused__))) { return EMPTY_TQ; }
+
+GLOBAL int tq_equal(TypeQual a, TypeQual b) { return a.tq==b.tq; }
diff -Nur 5.4.2.2/cilk2c/typequal.h current.Bug188/cilk2c/typequal.h
--- 5.4.2.2/cilk2c/typequal.h	1970-01-01 00:00:00.000000000 +0000
+++ current.Bug188/cilk2c/typequal.h	2005-10-22 02:52:37.000000000 +0000
@@ -0,0 +1,189 @@
+#include <stdarg.h>
+/* TypeQual: storage classes, type qualifiers, and additional attributes */
+
+/* First the old definition.  Using the enumeration types directly is deprecated. */
+
+typedef struct typequal {
+    unsigned int tq;
+    List *attributes;
+} TypeQual;
+#define EMPTY_TQ ((TypeQual){0,0})
+
+GLOBAL TypeQual tq_attribute (List *attrib);
+
+/* These are the new typequal operations.   Use these. */
+
+GLOBAL int tq_has_auto (TypeQual);
+GLOBAL int tq_has_extern (TypeQual);
+GLOBAL int tq_has_register (TypeQual);
+GLOBAL int tq_has_static (TypeQual);
+GLOBAL int tq_has_typedef (TypeQual);
+GLOBAL int tq_has_some_storageclass (TypeQual);
+
+GLOBAL TypeQual tq_add_auto (TypeQual);
+GLOBAL TypeQual tq_add_extern (TypeQual);
+GLOBAL TypeQual tq_add_register (TypeQual);
+GLOBAL TypeQual tq_add_static (TypeQual);
+GLOBAL TypeQual tq_add_typedef (TypeQual);
+
+GLOBAL TypeQual tq_storage_class (TypeQual);
+
+GLOBAL TypeQual tq_remove_register (TypeQual);
+GLOBAL TypeQual tq_remove_all_storage_classes (TypeQual);
+GLOBAL TypeQual tq_set_storage_class_from (TypeQual, TypeQual);
+
+#define TQ_AUTO (tq_add_auto(EMPTY_TQ))
+#define TQ_EXTERN (tq_add_extern(EMPTY_TQ))
+#define TQ_REGISTER (tq_add_register(EMPTY_TQ))
+#define TQ_STATIC (tq_add_static(EMPTY_TQ))
+#define TQ_TYPEDEF (tq_add_typedef(EMPTY_TQ))
+
+GLOBAL int tq_has_top_decl (TypeQual);
+GLOBAL int tq_has_block_decl (TypeQual);
+GLOBAL int tq_has_formal_decl (TypeQual);
+GLOBAL int tq_has_su_decl (TypeQual);
+GLOBAL int tq_has_enum_decl (TypeQual);
+
+GLOBAL TypeQual tq_add_top_decl (TypeQual);
+GLOBAL TypeQual tq_add_block_decl (TypeQual);
+GLOBAL TypeQual tq_add_formal_decl (TypeQual);
+GLOBAL TypeQual tq_add_su_decl (TypeQual);
+GLOBAL TypeQual tq_add_enum_decl (TypeQual);
+
+#define TQ_TOP_DECL (tq_add_top_decl(EMPTY_TQ))
+#define TQ_BLOCK_DECL (tq_add_block_decl(EMPTY_TQ))
+#define TQ_FORMAL_DECL (tq_add_formal_decl(EMPTY_TQ))
+#define TQ_SU_DECL (tq_add_su_decl(EMPTY_TQ))
+#define TQ_ENUM_DECL (tq_add_enum_decl(EMPTY_TQ))
+
+GLOBAL TypeQual tq_decl_location (TypeQual);
+GLOBAL TypeQual tq_set_decl_location_from (TypeQual tq, TypeQual source);
+
+/* Flag for redundant external declaration, which is defined as
+ * an external declaration (NOT a definition, so it must have no
+ * initializer or function body) of a name previously declared external 
+ * in the same scope.  A trivial example:
+ *    extern int x;
+ *    extern int x;    <-- redundant
+ * But:
+ *    { extern int x; }
+ *    { extern int x; }  <-- not redundant
+ * because the two declarations have different scopes.
+ */
+GLOBAL int tq_has_redundant_external_decl (TypeQual);
+GLOBAL TypeQual tq_add_redundant_external_decl(TypeQual);
+GLOBAL TypeQual tq_remove_redundant_external_decl(TypeQual);
+#define TQ_REDUNDANT_EXTERNAL_DECL (tq_add_redundant_external_decl(EMPTY_TQ))
+
+GLOBAL int tq_has_shared (TypeQual);
+GLOBAL int tq_has_private (TypeQual); /* does it have a private decl? */
+GLOBAL int tq_has_nooutput (TypeQual);
+GLOBAL int tq_has_cilkonly (TypeQual);
+GLOBAL int tq_has_cilksafe (TypeQual);
+
+GLOBAL TypeQual tq_add_shared (TypeQual);
+GLOBAL TypeQual tq_add_private (TypeQual);
+GLOBAL TypeQual tq_add_nooutput (TypeQual);
+GLOBAL TypeQual tq_add_cilkonly (TypeQual);
+GLOBAL TypeQual tq_add_cilksafe (TypeQual);
+
+#define TQ_SHARED (tq_add_shared(EMPTY_TQ))
+#define TQ_PRIVATE (tq_add_private(EMPTY_TQ))
+#define TQ_NOOUTPUT (tq_add_nooutput(EMPTY_TQ))
+#define TQ_CILKONLY (tq_add_cilkonly(EMPTY_TQ))
+#define TQ_CILKSAFE (tq_add_cilksafe(EMPTY_TQ))
+
+/* Cilk "where-am-i" declaration specifiers. */
+GLOBAL int tq_has_fast_procedure (TypeQual);
+GLOBAL int tq_has_slow_procedure (TypeQual);
+GLOBAL int tq_has_fast_inlet (TypeQual);
+GLOBAL int tq_has_slow_inlet (TypeQual);
+GLOBAL int tq_has_standalone_inlet (TypeQual);
+GLOBAL int tq_has_c_code (TypeQual);
+
+GLOBAL TypeQual tq_add_fast_procedure (TypeQual);
+GLOBAL TypeQual tq_add_slow_procedure (TypeQual);
+GLOBAL TypeQual tq_add_fast_inlet (TypeQual);
+GLOBAL TypeQual tq_add_slow_inlet (TypeQual);
+GLOBAL TypeQual tq_add_standalone_inlet (TypeQual);
+GLOBAL TypeQual tq_add_c_code (TypeQual);
+
+#define TQ_FAST_PROCEDURE (tq_add_fast_procedure(EMPTY_TQ))
+#define TQ_SLOW_PROCEDURE (tq_add_slow_procedure(EMPTY_TQ))
+#define TQ_FAST_INLET (tq_add_fast_inlet(EMPTY_TQ))
+#define TQ_SLOW_INLET (tq_add_slow_inlet(EMPTY_TQ))
+#define TQ_STANDALONE_INLET (tq_add_slow_inlet(EMPTY_TQ))
+#define TQ_C_CODE (tq_add_c_code(EMPTY_TQ))
+
+GLOBAL int tq_has_cilk_where_am_i_decl_quals(TypeQual);
+GLOBAL TypeQual tq_remove_cilk_where_am_i_decl_quals(TypeQual); /* Remove the cilk "where-am-i" declaration qualifiers */
+
+GLOBAL TypeQual TQ_DECL_QUALS(void);
+GLOBAL TypeQual tq_decl_quals(TypeQual); /* Get out the decl qualifiers */
+
+/* Type qualifiers. */
+GLOBAL TypeQual tq_add_restrict (TypeQual);
+GLOBAL TypeQual tq_add_complex (TypeQual);
+
+#define TQ_RESTRICT (tq_add_restrict(EMPTY_TQ))
+#define TQ_COMPLEX (tq_add_complex(EMPTY_TQ))
+
+#define TQ_CONST (tq_add_const(EMPTY_TQ))
+#define TQ_VOLATILE (tq_add_volatile(EMPTY_TQ))
+#define TQ_INLINE (tq_add_inline(EMPTY_TQ))
+#define TQ_SUE_ELABORATED (tq_add_sue_elaborated(EMPTY_TQ))
+
+#define TQ_PROCEDURE (tq_add_procedure(EMPTY_TQ))
+#define TQ_INLET (tq_add_inlet(EMPTY_TQ))
+#define TQ_EXTENSION (tq_add_extension(EMPTY_TQ))
+
+GLOBAL int tq_has_restrict (TypeQual);
+GLOBAL int tq_has_complex (TypeQual);
+GLOBAL int tq_has_const (TypeQual);
+GLOBAL int tq_has_volatile (TypeQual);
+GLOBAL int tq_has_inline(TypeQual);
+GLOBAL int tq_has_sue_elaborated (TypeQual); /* on an Sdcl/Udcl/Edcl, did the SUE's field list appear at that point in the source? */
+GLOBAL int tq_has_procedure(TypeQual);
+GLOBAL int tq_has_inlet(TypeQual);
+GLOBAL int tq_has_extension (TypeQual);
+
+GLOBAL TypeQual tq_add_restrict (TypeQual);
+GLOBAL TypeQual tq_add_complex (TypeQual);
+GLOBAL TypeQual tq_add_const (TypeQual);
+GLOBAL TypeQual tq_add_volatile(TypeQual);
+GLOBAL TypeQual tq_add_inline (TypeQual);
+GLOBAL TypeQual tq_add_sue_elaborated (TypeQual);
+GLOBAL TypeQual tq_add_procedure (TypeQual);
+GLOBAL TypeQual tq_add_inlet (TypeQual);
+GLOBAL TypeQual tq_add_extension (TypeQual);
+
+GLOBAL TypeQual tq_remove_complex(TypeQual);
+GLOBAL TypeQual tq_remove_const (TypeQual);
+GLOBAL TypeQual tq_remove_inline (TypeQual);
+GLOBAL TypeQual tq_remove_sue_elaborated (TypeQual);
+GLOBAL TypeQual tq_remove_procedure (TypeQual);
+GLOBAL TypeQual tq_remove_inlet (TypeQual);
+
+GLOBAL TypeQual tq_type_quals (TypeQual);
+GLOBAL TypeQual tq_remove_compatible (TypeQual);
+
+GLOBAL TypeQual tq_remove_all_decl_quals (TypeQual);
+//TypeQual tq_add_decl_quals_from (TypeQual, TypeQual);
+
+GLOBAL TypeQual tq_union (TypeQual, TypeQual); /* Produce a type qualifier which is the union of two others. */
+GLOBAL TypeQual tq_intersection (TypeQual, TypeQual);
+GLOBAL TypeQual tq_subtract (TypeQual, TypeQual);
+
+GLOBAL int tq_has_anything (TypeQual);
+GLOBAL TypeQual tq_remove_everything (TypeQual);
+
+//GLBOAL int tq_has_cilkonly (TypeQual);
+
+//#define EMPTY_TQ ((TypeQual){0,0})
+
+GLOBAL int tq_equal(TypeQual, TypeQual);
+
+// Always print a space at the end.
+GLOBAL void TQtoGBUF(GBUF *gb, TypeQual tq);
+
+
diff -Nur 5.4.2.2/cilk2c/verify-parse.c current.Bug188/cilk2c/verify-parse.c
--- 5.4.2.2/cilk2c/verify-parse.c	2004-10-23 03:26:20.000000000 +0000
+++ current.Bug188/cilk2c/verify-parse.c	2005-10-22 02:52:37.000000000 +0000
@@ -31,7 +31,7 @@
 #include "ast.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/cilk2c/verify-parse.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/cilk2c/verify-parse.c $ $LastChangedBy: bradley $ $Rev: 2455 $ $Date$");
 
 
 typedef enum verifycontext {
@@ -298,7 +298,7 @@
 
 PRIVATE inline void VerifyAdcl(UNUSED(Node *node), adclNode *u, UNUSED(Context c))
 {
-     assert(u->tq == EMPTY_TQ);
+     assert(!tq_has_anything(u->tq));
      VerifyType(u->type);
      if (u->dimp->dim)
 	  VerifyExpr(u->dimp->dim);	/* can be null */
@@ -307,9 +307,9 @@
 PRIVATE inline void VerifyFdcl(UNUSED(Node *node), fdclNode *u, UNUSED(Context c))
 {
      /* allow inlet --- commented by fengmd */
-     assert(u->tq == EMPTY_TQ || u->tq == T_INLINE || u->tq == T_PROCEDURE ||
-	    u->tq == (T_INLINE | T_PROCEDURE) || u->tq == T_INLET ||
-	    u->tq == (T_INLINE | T_INLET));
+     assert(!tq_has_anything(u->tq) || tq_equal(u->tq, TQ_INLINE) || tq_equal(u->tq, TQ_PROCEDURE) ||
+	    tq_equal(u->tq, tq_add_inline(TQ_PROCEDURE)) || tq_equal(u->tq, TQ_INLET) ||
+	    tq_equal(u->tq, tq_add_inline(TQ_INLET)));
      VerifyType(u->returns);
      VerifyDeclList(u->args, FormalParm);
 }
@@ -321,7 +321,7 @@
      assert(u->type->typ == Sdcl);
      /* u->type->name could be NULL */
 
-     if (SUE_ELABORATED(u->tq)) {
+     if (tq_has_sue_elaborated(u->tq)) {
 	  VerifyDeclList(u->type->fields, StructField);
      }
 }
@@ -333,7 +333,7 @@
      assert(u->type->typ == Udcl);
      /* u->type->name could be NULL */
 
-     if (SUE_ELABORATED(u->tq)) {
+     if (tq_has_sue_elaborated(u->tq)) {
 	  VerifyDeclList(u->type->fields, StructField);
      }
 }
@@ -535,18 +535,16 @@
 
 PRIVATE void VerifyTq(TypeQual tq)
 {
-     assert(tq == TYPE_QUALS(tq));
+     assert(tq_equal(tq, tq_type_quals(tq)));
 }
 
 PRIVATE void VerifyScAndDq(TypeQual tq)
 {
-     int sc = STORAGE_CLASS(tq);
-     int dl = DECL_LOCATION(tq);
-     assert(sc == 0 || sc == T_TYPEDEF || sc == T_EXTERN
-	    || sc == T_STATIC || sc == T_AUTO || sc == T_REGISTER);
-     assert(dl == T_TOP_DECL || dl == T_BLOCK_DECL || dl == T_FORMAL_DECL ||
-	    dl == T_SU_DECL || dl == T_ENUM_DECL);
-     assert(TYPE_QUALS(tq) == 0);
+     assert(!tq_has_some_storageclass(tq) || tq_has_typedef(tq) || tq_has_extern(tq)
+	    || tq_has_static(tq) || tq_has_auto(tq) || tq_has_register(tq));
+     assert(tq_has_top_decl(tq) || tq_has_block_decl(tq) || tq_has_formal_decl(tq) ||
+	    tq_has_su_decl(tq) || tq_has_enum_decl(tq));
+     assert(!tq_has_anything(tq_type_quals(tq)));
 }
 
 PRIVATE void VerifyType(Node *type)
diff -Nur 5.4.2.2/runtime/cilk-sysdep.h.in current.Bug188/runtime/cilk-sysdep.h.in
--- 5.4.2.2/runtime/cilk-sysdep.h.in	2004-10-23 03:26:12.000000000 +0000
+++ current.Bug188/runtime/cilk-sysdep.h.in	2005-09-27 03:58:53.000000000 +0000
@@ -143,7 +143,7 @@
 /******************************************************/
 
 FILE_IDENTITY(ident_cilk_sysdep_h,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/runtime/cilk-sysdep.h.in $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/runtime/cilk-sysdep.h.in $ $LastChangedBy: bradley $ $Rev: 2311 $ $Date$");
 
 /* The C compiler to use when compiling code for pthreads */
 #undef CILKC_PTHREAD_CC
@@ -198,20 +198,28 @@
        POWERPC 
  ------------------------*/
 #if defined(__powerpc__) || defined(__ppc__)
+/* This version contributed by Matteo Frigo Wed Jul 13 2005.   He wrote:
+ *   lwsync is faster than eieio and has the desired store-barrier
+ *   behavior.  The isync in the lock is necessary because the processor is
+ *   allowed to speculate on loads following the branch, which makes the
+ *   program without isync incorrect (in theory at least---I have never
+ *   observed such a speculation).
+ */
 #  define CILK_CACHE_LINE 64
 #  define CILK_MB()  __asm__ __volatile__ ("sync" : : : "memory")
 #  define CILK_RMB()  __asm__ __volatile__ ("sync" : : : "memory")
-#  define CILK_WMB()  __asm__ __volatile__ ("eieio" : : : "memory")
+#  define CILK_WMB()  __asm__ __volatile__ ("lwsync" : : : "memory")
 
    /* atomic swap operation */
-   static inline int Cilk_xchg(volatile int *ptr, int x)
+   static __inline__ int Cilk_xchg(volatile int *ptr, int x)
    {
 	int result;
 	__asm__ __volatile__ (
-	   "0: lwarx %0,0,%1\n stwcx. %2,0,%1\n bne- 0b" :
-	    "=&r"(result) : 
-	   "r"(ptr), "r"(x) :
-	    "cr0");
+	     "0: lwarx %0,0,%1\n stwcx. %2,0,%1\n bne- 0b\n isync\n" :
+	     "=&r"(result) : 
+             "r"(ptr), "r"(x) :
+	     "cr0");
+
 	return result;
    }
 #endif
diff -Nur 5.4.2.2/runtime/cilkrt0.c current.Bug188/runtime/cilkrt0.c
--- 5.4.2.2/runtime/cilkrt0.c	2004-10-23 03:26:12.000000000 +0000
+++ current.Bug188/runtime/cilkrt0.c	2005-09-27 03:58:53.000000000 +0000
@@ -30,10 +30,17 @@
  */
 
 #include <cilk-sysdep.h>
-#include <malloc.h>
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/runtime/cilkrt0.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/runtime/cilkrt0.c $ $LastChangedBy: bradley $ $Rev: 1875 $ $Date$");
+
+#if HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
 
 /* Sivan and Ofra 19 June 2003:
    the code in the #else block tries to generate a main that calls the user's 
diff -Nur 5.4.2.2/support/Makefile.am current.Bug188/support/Makefile.am
--- 5.4.2.2/support/Makefile.am	2004-10-23 03:26:50.000000000 +0000
+++ current.Bug188/support/Makefile.am	2005-10-05 16:47:03.000000000 +0000
@@ -21,7 +21,7 @@
 abs_top_builddir = $(shell (cd $(top_builddir); pwd))
 
 cilkclocal$(EXEEXT): cilkc.c make-temp-file.o
-	$(CC) -DCILKHEADER_DIR=$(abs_top_builddir)/runtime -DCILK2C_DIR=$(abs_top_builddir)/cilk2c -DLIBS_DIR=$(abs_top_builddir)/runtime/.libs -DLIBS2_DIR=$(abs_top_builddir)/runtime -DHAVE_RPATH=@HAVE_RPATH@ -DHAVE_RPATHARG=@HAVE_RPATHARG@ $^ -o $@ $(AM_CFLAGS) $(CFLAGS)
+	$(CC) -DCILKHEADER_DIR="$(abs_top_builddir)"/runtime -DCILK2C_DIR="$(abs_top_builddir)"/cilk2c -DLIBS_DIR="$(abs_top_builddir)"/runtime/.libs -DLIBS2_DIR="$(abs_top_builddir)"/runtime -DHAVE_RPATH=@HAVE_RPATH@ -DHAVE_RPATHARG=@HAVE_RPATHARG@ $^ -o $@ $(AM_CFLAGS) $(CFLAGS)
 cilkc$(EXEEXT): cilkc.c make-temp-file.o
 	$(CC) -DCILKHEADER_DIR=$(prefix)/include/cilk -DCILK2C_DIR=$(prefix)/bin -DLIBS_DIR=$(libdir) -DLIBS2_DIR=$(libdir)/cilk $^ -o $@ $(AM_CFLAGS) $(CFLAGS)
 
diff -Nur 5.4.2.2/support/Makefile.in current.Bug188/support/Makefile.in
--- 5.4.2.2/support/Makefile.in	2004-10-23 03:26:49.000000000 +0000
+++ current.Bug188/support/Makefile.in	2005-10-05 16:47:47.000000000 +0000
@@ -404,7 +404,7 @@
 
 
 cilkclocal$(EXEEXT): cilkc.c make-temp-file.o
-	$(CC) -DCILKHEADER_DIR=$(abs_top_builddir)/runtime -DCILK2C_DIR=$(abs_top_builddir)/cilk2c -DLIBS_DIR=$(abs_top_builddir)/runtime/.libs -DLIBS2_DIR=$(abs_top_builddir)/runtime -DHAVE_RPATH=@HAVE_RPATH@ -DHAVE_RPATHARG=@HAVE_RPATHARG@ $^ -o $@ $(AM_CFLAGS) $(CFLAGS)
+	$(CC) -DCILKHEADER_DIR="$(abs_top_builddir)"/runtime -DCILK2C_DIR="$(abs_top_builddir)"/cilk2c -DLIBS_DIR="$(abs_top_builddir)"/runtime/.libs -DLIBS2_DIR="$(abs_top_builddir)"/runtime -DHAVE_RPATH=@HAVE_RPATH@ -DHAVE_RPATHARG=@HAVE_RPATHARG@ $^ -o $@ $(AM_CFLAGS) $(CFLAGS)
 cilkc$(EXEEXT): cilkc.c make-temp-file.o
 	$(CC) -DCILKHEADER_DIR=$(prefix)/include/cilk -DCILK2C_DIR=$(prefix)/bin -DLIBS_DIR=$(libdir) -DLIBS2_DIR=$(libdir)/cilk $^ -o $@ $(AM_CFLAGS) $(CFLAGS)
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff -Nur 5.4.2.2/support/cilkc.c current.Bug188/support/cilkc.c
--- 5.4.2.2/support/cilkc.c	2004-10-23 03:26:50.000000000 +0000
+++ current.Bug188/support/cilkc.c	2005-09-27 03:58:58.000000000 +0000
@@ -14,6 +14,7 @@
  *    
  * Arguments
  *   *.cilk                   treat as a cilk file
+ *   *.cilkp                  treat a file that simply #includes the header file and the .cilk file (don't add the header to this one.)
  *   *.cilki                  treat as a cilk file that has been preprocessed
  *   *.cilkc                  treat as a C file that has been produced by cilk2c
  *   *.c *.o *.i other files  treat as the C compielr would
@@ -37,6 +38,7 @@
  *   -O*                      optimize (e.g., -O2, just like gcc)
  *   -f*                      optimization arguments (gcc-specific)
  *   -m*                      machine-specific options (gcc-specific)
+ *   --param <argument>       Passed to the compiler (at Matteo's suggestion:  Bug 183)
  *   -woff <argument>         turn off warnings (mipspro C specific)
  *   -Wl,* -l* -L* -static    linker options (passed without modification, e.g., including the "-Wl,".)
  *   -Wp,*                    preprocessor options (works for gcc and mipspro)
@@ -72,7 +74,7 @@
 #include "make-temp-file.h"
 
 FILE_IDENTITY(ident,
-	      "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/support/cilkc.c $ $LastChangedBy: bradley $ $Rev: 1708 $ $Date$");
+	      "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/support/cilkc.c $ $LastChangedBy: bradley $ $Rev: 2311 $ $Date$");
 
 
 /* This macro hacking is what is needed to get RUNTIME_DIR to be expanded and then stringified */
@@ -167,7 +169,7 @@
     assert(ma->argv[ma->argc]==0);
     assert(ma->argc+1<=ma->limit);
     if (fout) {
-	fprintf(f, " > %s\n", fout);
+	fprintf(f, " > %s", fout);
     }
     fprintf(f, "\n");
 }
@@ -211,7 +213,7 @@
 
 
 enum LANG {
-    L_none, L_cilk, L_cilki, L_cilkc, L_c, L_m, L_cpp, L_h, L_i, L_ii, L_s, L_S
+    L_none, L_cilk, L_cilkp, L_cilki, L_cilkc, L_c, L_m, L_cpp, L_h, L_i, L_ii, L_s, L_S
 };
 
 enum LANG language_of_xarg (const char *xarg) {
@@ -234,6 +236,7 @@
     switch (l) {
     case L_none: return "none";
     case L_cilk: return "cilk";
+    case L_cilkp: return "cilkp";
     case L_cilki: return "cilki";
     case L_cilkc: return "cilkc";
     case L_c: return "c";
@@ -252,6 +255,7 @@
     if (latest_xarg!=L_none) return latest_xarg;
     else if (tailmatch(fname, ".cilk")) return L_cilk;
     else if (tailmatch(fname, ".cilki")) return L_cilki;
+    else if (tailmatch(fname, ".cilkp")) return L_cilkp;
     else if (tailmatch(fname, ".cilkc")) return L_cilkc;
     else if (tailmatch(fname, ".c")) return L_c;
     else if (tailmatch(fname, ".m")) return L_m;
@@ -296,12 +300,13 @@
 MY_ARGV cc_args=0;      /* All the arguments that will be passed to the big final call to cc */
 MY_ARGV cpp1_args=0;    /* All the arguments, except for the name of the .cilk input file and the name of the output file, to be passed to the first preprocessor */
 
-PAIRLIST i_files=0;     /* These are only the .i files produced by the cilk->cilki->cilkc->i chain
+PAIRLIST i_files=0;     /* These are only the .i files produced by the cilk->cilkp->cilki->cilkc->i chain
 			 * And only if we are producing an output
 			 * For the i_files the first elt is the .i file and the second is output file. */
 PAIRLIST cilkc_files=0; /* the first elt of each pair is the .cilkc file, the second (if any) is .i file */
 PAIRLIST cilki_files=0; /* the first elt of the pair is the .cilki file, the second (if any) is the .cilkc file */
-PAIRLIST cilk_files=0;  /* the first elt of the pair is the .cilk file, the second (if any) is the .cilki file */
+PAIRLIST cilkp_files=0; /* the first elt of the pair is the .cilkp file, the second (if any) is the .cilki file */
+PAIRLIST cilk_files=0;  /* the first elt of the pair is the .cilk file, the second (if any) is the .cilkp file */
 
 int n_gcc_files=0;      /* How many files are sent to gcc. */
 int n_input_files_that_can_make_one_output_file=0; /* How many input files produce a unique output file */
@@ -475,6 +480,22 @@
     }
 }
 
+void note_cilkp_file (const char *fname, const char *org_fname) {
+    switch (stop_at) {
+    case STOP_AT_M:
+	pushpair(&cilkp_files, fname, 0);
+	return;
+    default:
+	{
+	    const char *outfname = newtempfile(".cilki", fname);
+	    //fprintf(stderr, "%s:%d pushpair(&cilkp_files, \"%s\", \"%s\");\n", __FILE__, __LINE__, fname, outfname);
+	    pushpair(&cilkp_files, fname, outfname);
+	    note_cilki_file(outfname, org_fname);
+	    return;
+	}
+    }
+}
+
 void note_cilk_file (const char *fname, const char *org_fname) {
     switch (stop_at) {
     case STOP_AT_M:
@@ -482,9 +503,10 @@
 	return;
     default:
 	{
-	    const char *outfname = newtempfile(".cilki", fname);
+	    const char *outfname = newtempfile(".cilkp", fname);
+	    //fprintf(stderr, "%s:%d pushpair(&cilk_files, \"%s\", \"%s\");\n", __FILE__, __LINE__, fname, outfname);
 	    pushpair(&cilk_files, fname, outfname);
-	    note_cilki_file(outfname, org_fname);
+	    note_cilkp_file(outfname, org_fname);
 	}
 	return;
     }
@@ -539,6 +561,7 @@
 	    argc--; argv++;
 	    pusharg(cpp1_args, *argv);
 	    pusharg(cc_args, *argv);
+
 	} else if (headmatch(*argv,"-D") ||
 		   headmatch(*argv,"-A")  || /* assertions for preprocessor */
 		   headmatch(*argv,"-include")  ||
@@ -576,6 +599,12 @@
 	    pusharg(cc_early_args, *argv);
 	    pusharg(cc_args,       *argv);
 	    pusharg(cpp1_args,     *argv);
+	} else if (match(*argv, "--param")) {
+	    /* Pass this and the next argument to the compiler. */
+	    if (argc==1) barf("Missing arg to %s", *argv);
+	    pusharg(cc_args, *argv);
+	    argc--; argv++;
+	    pusharg(cc_args, *argv);
 	} else if (headmatch(*argv, "-Wc,")){  /* extra arguments to pass to the C compiler (works with any compiler by stripping of the -Wc, */
 	    pusharg(cc_early_args, (*argv)+4);
 	    pusharg(cc_args,       (*argv)+4);
@@ -624,6 +653,7 @@
 
 	    switch (lang_of_this_arg) {
 	    case L_cilk: 
+	    case L_cilkp:
 	    case L_cilki:
 	    case L_cilkc:
 	    case L_c:
@@ -631,8 +661,8 @@
 	    case L_cpp:
 	    case L_S:
 	      /*
-	       * cilk, cilki, cilkc, c, m, and cc files produce a separate output unless we finish
-	       * also assembler-with-cpp produces an output unless we finish
+	       * cilk, cilki, cilkc, c, m, and cc files produce a separate output unless we finish.
+	       * also assembler-with-cpp produces an output unless we finish.
 	       */
 	      if (!finish_up) n_input_files_that_can_make_one_output_file++; /* cilk files produce a separate output unless we finish */
 		break;
@@ -654,6 +684,7 @@
 	    /**/;
 	    switch (lang_of_this_arg) {
 	    case L_cilk:  note_cilk_file(*argv, *argv);  break;
+	    case L_cilkp: note_cilkp_file(*argv, *argv); break;
 	    case L_cilki: note_cilki_file(*argv, *argv); break;
 	    case L_cilkc: note_cilkc_file(*argv, *argv); break;
 	    case L_c:
@@ -749,27 +780,32 @@
     return !(WIFEXITED(status) && WEXITSTATUS(status)==0);
 }
 
-const char * make_including_cilkh_file (const char *fname) {
-    const char *tmpfname = make_temp_file(".cilk");
-    FILE *f = fopen(tmpfname, "w");
+void make_cilkp_file (const char *included_fname, const char *including_fname) {
+    FILE *f;
+    assert(included_fname);
+    assert(including_fname);
+    f = fopen(including_fname, "w");
     fprintf(f, "#include \"%s\"\n", CILK_H_LOCATION);
-    if (fname[0]=='/') {
-	fprintf(f, "#include \"%s\"\n", fname);
+    VERBOSE(1, fprintf(stderr, "(echo \\#include \"%s\";", CILK_H_LOCATION));
+    if (included_fname[0]=='/') {
+	fprintf(f, "#include \"%s\"\n", included_fname);
+	VERBOSE(1, fprintf(stderr, "echo \\#include \"%s\")", included_fname));
     } else {
 	/* If it is a relative pathname, make it absolute. */
 	char cwd[PATH_MAX];
 	getcwd(cwd, PATH_MAX);
-	fprintf(f, "#include \"%s/%s\"\n", cwd, fname);
+	fprintf(f, "#include \"%s/%s\"\n", cwd, included_fname);
+	VERBOSE(1, fprintf(stderr, "echo \\#include \"%s/%s\")", cwd, included_fname));
     }
+    VERBOSE(1, fprintf(stderr, "> %s\n", including_fname));
     fclose(f);
-    pushstring(&more_tempfiles_to_delete, tmpfname);
     /*{
 	char foo[1000];
 	printf("Created %s, which contains\n", tmpfname);
 	snprintf(foo, 999, "cat %s", tmpfname);
 	system(foo);
     }*/
-    return tmpfname;
+    //printf("%s:%d %s\n", __FILE__, __LINE__, tmpfname);
 }
 
 void do_M (void) {
@@ -787,8 +823,7 @@
 	{
 	    PAIRLIST cf;
 	    for (cf=cilk_files; cf; cf=cf->rest) {
-		assert(cf->b==0);
-		pusharg(ma, make_including_cilkh_file(cf->a));
+		pusharg(ma, cf->a);
 	    }
 	}
 	pushargs(ma, cpp1_args);
@@ -819,6 +854,9 @@
 void do_cpp1(void) {
     PAIRLIST cf;
     for (cf=cilk_files; cf; cf=cf->rest) {
+	make_cilkp_file(cf->a, cf->b);
+    }
+    for (cf=cilkp_files; cf; cf=cf->rest) {
 	MY_ARGV ma = make_my_argv();
 	pusharg(ma, get_cc());
 	pusharg(ma, "-E");
@@ -828,7 +866,7 @@
 	} else {
 	    pusharg(ma, "-ignore_suffix");
 	}
-	pusharg(ma, make_including_cilkh_file(cf->a));
+	pusharg(ma, cf->a);
 	assert(cf->b);
 	pushargs(ma, cpp1_args);
 	/* 
@@ -1032,7 +1070,7 @@
 	"                      c++cpp-output .ii files (preprocessed c++ files)\n",
 	"                      assembler     .s files\n",
 	"                      assembler-with-cpp .S files\n",
-	"Options to contro the C compiler:\n",
+	"Options to control the C compiler:\n",
 	" -Wc,*                pass the * argument to the C compiler.  For example when using the mipspro compiler you could do\n",
         "                          -Wc,-use_readwrite_const    to put constants into readwrite memory, or\n",
 	"                          -Wc,-Wa,-foo                which would pass -Wa,-foo to the C compiler, which in turn would pass -foo to the assembler.\n",
@@ -1049,7 +1087,7 @@
 
 void do_operations (void) {
     if (verbose>=1 || do_print_version) {
-	fprintf(stderr, "cilkc %s\n", "$Rev: 1708 $ $Date$");
+	fprintf(stderr, "cilkc %s\n", "$Rev: 2311 $ $Date$");
     }
     if (do_print_help) {
 	print_help();
diff -Nur 5.4.2.2/support/cilkcB.c current.Bug188/support/cilkcB.c
--- 5.4.2.2/support/cilkcB.c	2004-10-23 03:26:50.000000000 +0000
+++ current.Bug188/support/cilkcB.c	2005-09-27 03:58:58.000000000 +0000
@@ -36,7 +36,7 @@
  * other gcc-style arguments to be added later
  */
 static const char *ident __attribute__((__unused__))
-     = "$HeadURL: https://bradley.lcs.mit.edu/svn/repos/cilk/5.4.2.2/support/cilkcB.c $ $LastChangedBy: sukhaj $ $Rev: 1708 $ $Date$";
+     = "$HeadURL: https://bradley.csail.mit.edu/svn/repos/cilk/current.Bug188/support/cilkcB.c $ $LastChangedBy: sukhaj $ $Rev: 773 $ $Date$";
 
 #include <assert.h>
 #include <stdarg.h>
@@ -462,7 +462,7 @@
 }
 
 int do_operations(void) {
-    VERBOSE(1, fprintf(stderr, "cilkc $Rev: 1708 $ $Date$\n"));
+    VERBOSE(1, fprintf(stderr, "cilkc $Rev: 773 $ $Date$\n"));
     pushstring(&cpp1_args, "-I" XSTR(CILKHEADER_DIR) );
     pushstring(&cpp1_args, "-D__CILK__");
     pushstring(&cpp1_args, "-D__CILK2C__");
diff -Nur 5.4.2.2/support/make-temp-file.c current.Bug188/support/make-temp-file.c
--- 5.4.2.2/support/make-temp-file.c	2004-10-23 03:26:50.000000000 +0000
+++ current.Bug188/support/make-temp-file.c	2005-09-27 03:58:58.000000000 +0000
@@ -51,11 +51,10 @@
 #endif
 
 #include "make-temp-file.h"
-#define PARAMS(x) x
 
 /* Call it mkstemps_local instead of mkstemps so that I don't get a conflict against the bsd mkstemps() (defined on some systems such as macos X)
  * The bsd mkstemps probably does the right thing, but I don't want to test it, so I'll just name rename this one. */
-static int mkstemps_local PARAMS ((char *, int));
+static int mkstemps_local (char *, int);
 
 /* '/' works just fine on MS-DOS based systems.  */
 #ifndef DIR_SEPARATOR
@@ -73,19 +72,20 @@
    If success, DIR is returned.
    Otherwise NULL is returned.  */
 
-static inline const char *try PARAMS ((const char *, const char *));
-
-static inline const char *
-try (dir, base)
-     const char *dir, *base;
+static inline const char *TRY (const char *dir, const char *base, int line)
 {
-  if (base != 0)
-    return base;
-  if (dir != 0
-      && access (dir, R_OK | W_OK | X_OK) == 0)
-    return dir;
-  return 0;
+    line=line; /* get rid of unused variable warning) */
+    if (base != 0) {
+	return base;
+    }
+    if (dir != 0
+	&& access (dir, R_OK | W_OK | X_OK) == 0) {
+	//printf("%s:%d in line %d: found %s\n", __FILE__, __LINE__, line, dir);
+	return dir;
+    }
+    return 0;
 }
+#define try(x,y) TRY(x,y,__LINE__)
 
 static const char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };
 static const char usrtmp[] =
@@ -136,11 +136,16 @@
   /* Append DIR_SEPARATOR to the directory we've chosen
      and return it.  */
   len = strlen (base);
-  tmpdir = malloc (len + 2);
-  assert(tmpdir);
-  strcpy (tmpdir, base);
-  tmpdir[len] = DIR_SEPARATOR;
-  tmpdir[len+1] = '\0';
+  assert(len>0);
+  if (base[len-1]==DIR_SEPARATOR) {
+      tmpdir = strdup(base);
+  } else {
+      tmpdir = malloc (len + 2);
+      assert(tmpdir);
+      strcpy (tmpdir, base);
+      tmpdir[len] = DIR_SEPARATOR;
+      tmpdir[len+1] = '\0';
+  }
 
   memoized_tmpdir = tmpdir;
   return tmpdir;
